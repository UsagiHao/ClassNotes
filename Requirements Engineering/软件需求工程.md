# 软件需求工程

## 1 软件需求导论

### 1.1 软件生产中的需求问题

需求问题是当前软件开发面临的主要问题。  
软件的三种类别：  

- 面向专业用户的纯工具型软件
- 面向普通用户的纯工具型软件
- 应用型软件  

它们具有不同的关注点和评判标准，分别对应创新性、有效性和模拟性。不同的评判标准和关注点决定了3类软件在生产中也会有所不同，尤其是在分析阶段具有截然不同的目标。  
</br>
应用软件正确工作的基础是具有“模拟”性，具体是指：

- 目的性：软件的目标是直接或间接地满足用户的某些目的或者解决用户的某些问题
- 正确性
- 现实可理解性：软件实现其功能的基础、手段和过程是在用户领域内现实可理解的。
  现实中常常对此类软件的“模拟”特性与应用问题缺乏重视  

需求问题的具体技术原因分析：    

- 理解需求处理中的非技术性和社会性因素：组织机构文化、社会背景、商业目标、利益协商
- 结构化分析和面向对象分析具有一定的先天缺陷
- 以企业为中心的软件反映出软件规模的扩大
- 纠正需求的错误需要极高的代价  

### 1.2 需求工程

#### 1.2.1 需求工程简介

**需求工程定义：**是软件工程的一个分支，它关注于软件系统所应予实现的现实世界目标、软件系统的功能和软件系统应当遵守的约束，同时它也关注以上因素和准确的软件行为规格说明之间的联系，关注以上因素与其随时间或跨产品族而演化之后的相关因素之间的联系。  
需求工程的基本活动：  

- 需求开发
  - 需求获取
  - 需求分析
  - 需求规格说明
  - 需求验证
- 需求管理  

#### 1.2.2 需求工程与系统工程

系统需求开发-早期阶段；软件需求开发-后期阶段。  

#### 1.2.3 需求工程的重要性

特定问题的具体特性掩盖了需求工程的重要性：问题广为人知；问题小而简单。

#### 1.2.4 需求工程的复杂性

处理范围广泛；涉及诸多参与方；处理内容多样；处理活动互相交织；处理结果要求苛刻。  

### 1.3 需求工程师

需求工程师是涉众与开发者之间的桥梁。  
需求工程师需要重视软技能（交流、观察、抽象分析和问题解决、写作、关系协调与团队工作）  

## 2 需求基础

### 2.1 需求的定义

1. 用户为了解决问题或达到某些目标所需要的条件或能力；
2. 系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；
3. 对（1）或（2）中的一个条件或一种能力的一种文档化表述。  

### 2.2 满足需求就是解决问题

#### 2.2.1 问题与需求

现实的状况与人们期望的状况产生差距时，就产生了问题。  
开发软件系统的目的就是希望用它作为解决方案来解决问题，使现实改善到期望的状况。  

#### 2.2.2 问题解决的两个方面——问题域与解系统

**问题域：** 问题的发生地，也是问题解决的基本范围——解决问题必须涉及的事件和事物。问题域是需求的背景，问题域的背景信息（问题域自治的规律性）又称为问题域特性（包括结构特性和行为特性）。需要额外关注间接特性、约束与假设。  
**解系统：** 软件系统通过影响问题域帮助人们解决问题，称之为解系统。  
问题域与需求：**需求**是用户对问题域中的实体状态或事件的期望描述。需求开发最原始的出发点就是用户需求，或者需求的源头——问题。  
解系统与需求规格说明：**需求规格说明**是解系统为满足用户需求而提供的解决方案，规定了解系统的行为特征。  

#### 2.2.3 问题解决的基础——模拟与共享现象

问题域与解系统能够形成互动的基础是解系统部分模拟了问题域，称之为共享现象。  

#### 2.2.4 问题解决的方法——直接与间接

模拟并操纵共享现象是软件系统满足需求最直接的方法，但有些情况下软件系统也会使用间接的方法解决问题：软件系统操纵共享现象影响问题域的一部分，然后利用问题域内在的规律性自动影响另一部分

#### 2.2.5 问题解决方案——需求规格说明

主要包括：对共享现象（模型）的描述和对系统对共享对象所施加的操作的描述。  

#### 2.2.6 问题解决的困难性

1. 不存在描述明确的问题域特性E；
2. 不存在确定的针对定义良好的系统行为S的评估标准R（符合预期的需求）；
3. E=>S是一个创造性的过程。  

需求工程的主要工作：  

- 需求开发,确定R 
- 研究问题背景，描述问题域特性E 
- 构建解系统，描述解系统行为S，使得E,S|->R  

### 2.3 需求和问题都具有层次性

需求最常见的抽象层次：  

- 业务需求：针对整个业务的期望
- 用户需求：针对具体任务的期望
- 系统级需求：针对系统和用户一次交互的期望。  

#### 2.3.1 战略问题与业务需求

业务需求是抽象层次最高的需求，是系统建立的战略出发点，表现为高层次的目标，描述了组织为什么要开发系统。  
为了满足用户的业务需求，需求工程师需要描述系统高层次的解决方案（逐一细化），定义系统应该具备的特性。  

#### 2.3.2 任务问题与用户需求

用户需求就是执行实际工作的用户对系统所能完成的具体任务的期望，描述了系统能够帮助用户做些什么。  
**用户：** 直接用户和间接用户（通用、公共服务软件等用户无法确定的系统）  
基本表达方式：XX用户可以使用系统完成XX任务。  
用户需求的特点：  

- 模糊、不清晰：允许使用形容词和副词  
- 多特性混杂：允许混合功能和非功能性需求  
- 多逻辑混杂：一条用户需求所代表的任务需多次系统交互才能完成  

#### 2.3.3 系统行为问题与系统级需求

适合软件开发者的需求层次是系统级需求。用户对系统行为的期望，一系列的系统行为联系在一起可以帮助用户完成任务，满足业务需求。  
基本表达方式：系统可以XXX；在XXX用户提出XXX请求时，系统应该XXX。  

## 3 需求工程过程

### 3.1 概述

需求工程过程是系统开发当中需求开发活动的集成。它的目标是产生一个能够在用户环境下解决用户业务问题的系统方案，并将其文档化为明确的规格说明。  
获取、分析、规格说明和验证并不是以线性顺序的执行，而是互相交织、迭代和递增的。

### 3.2 需求工程活动

#### 3.2.1 需求获取

需求获取是从人、资料或者环境当中获取需求的过程。需求获取和需求分析是交织在一起的。  
需求工程师需要执行的任务包括：

- 收集背景资料：深入了解以形成基础的知识框架。
- 获取问题与目标，定义项目的前景与范围：前景应对冲突、范围排除不必要的请求，坚定客户投资信心
- 识别涉众，选择信息的来源：来源：用户、硬数据、产品/专家/文档
- 选择获取方法，执行获取，获取功能与非功能需求：面谈、调查表、观察、原型等
- 记录获取结果：项目前景与范围文档、笔录记录

#### 3.2.2 需求分析

需求分析的主要工作是通过建模来整合各种信息，以使得人们更好的理解问题。同时为问题定义出一个需求集合，这个集合能够为问题界定一个有效的解决方案。还需要检查需求当中存在的错误、遗漏、不一致等各种缺陷，并加以修正。  
需求工程师的主要任务：

- 背景分析：研究系统将要部署的环境
- 问题分析、目标分析、业务分析、确定系统边界
- 需求建模
- 细化需求：用户需求转化为系统级需求
- 确定优先级
- 需求协商

#### 3.2.3 需求规格说明

编写文档的主要目的是为了在系统涉众之间交流需求信息：

- 业务需求——项目前景和范围文档
- 用户需求——用户需求文档（或者用例文档）
- 系统需求——需求规格说明
- 主要工作：定制文档模板——编写文档

#### 3.2.4 需求验证

确保文档满足标准：

- 文档内每条需求都正确、准确的反映了用户的意图
- 文档记录的需求集在整体上具有完整性和一致性
- 文档的组织方式和需求的书写方式具有可读性和可修改性
- 主要工作：执行验证（同级评审、原型、模拟）——问题修正（跟踪以确保落实）

#### 3.2.5 需求管理

主要工作：

- 建立和维护需求基线集 ：版本控制
- 建立需求跟踪信息（后向：制品，前向：高层需求）
- 进行变更控制：策略、团队

### 3.3 需求开发的过程是迭代和并发的

RT.

### 3.4 实践方法的应用

#### 3.4.1 细节知识的实践性

个人才智——实践方法——知识体系

#### 3.4.2 重要的实践方法

课本表3-1和3-2  
之后的章节会逐步介绍  

### 3.5 需求开发过程实例

- 螺旋模型：风险驱动项目的需求开发
- 原型模型：借鉴原型和分析模型的验证作用
- HP两阶段的需求开发过程模型
- 基于需求实践方法建立的需求开发模型
- 敏捷软件开发方法使用的需求开发模型
- RUP过程框架的需求开发模型

### 3.6 需求开发过程与软件工程过程的相互影响

需求工程过程是软件工程过程的一部分。  相比于需求方法本身的好坏，需求方法与软件开发方法的适配性更会影响项目的成败。

## 4 需求获取概述  

### 4.1 需求获取的非平凡性  

- 用户和开发人员的背景不同，立场不同  
- 普通用户缺乏概括性、综合性的表述能力：开发人员在与用户接触之前就先行确定获取的内容主题，然后设计具体的应用环境和场景条件，由用户根据细节业务的执行来描述问题、表达期望。  
- 用户存在认知困境  
- 用户越庖代俎：用户提出的不是需求而是解决方案/固执的坚持某些特征和功能  
- 缺乏用户参与  

### 4.2 需求获取的活动过程  

#### 4.2.1 需求获取的子活动  

- 研究应用背景，建立初始的知识框架；  
- 根据获取的需要，采用必要的获取方法和技巧；  
- 先行确定获取的内容和主题，设定场景；  
- 分析用户的高（深）层目标，理解用户的意图；  
- 进行涉众分析，针对涉众的特点开展工作。  

#### 4.22 需求获取的活动过程  

图略  

### 4.3 需求获取活动的要点  

1. 获取的内容：在项目的范围之内；不是一次得到的，而是逐步积累的；  
2. 获取的来源：涉众、相关产品、硬数据  
3. 获取的方法：传统方法、原型等  
4. 获取的过程：维护项目的前景和范围；不要以抽象和模糊的需求作为结束；**结束获取活动的判断条件**（p83）  
5. 获取的结果：可以产生项目前景和范围文档、用例文档  

### 4.4 需求获取的实践情况调查  

略

### 小结  

- 需求获取的成功执行需要有效组织子活动过程
- 执行需求获取时既要尽可能全面，又要防止不完备，更要注意进行过程控制

；

## 5 确定项目的前景与范围

### 5.1 引言

定义项目前景、定义项目范围。  
确定项目前景和范围的活动是定义业务需求和能够满足需求的高层解决方案。如果存在不同业务需求之间的冲突，那么在确定项目前景和范围阶段必须予以解决。  
**确定项目的前景与范围，就是确定项目的问题、目标、特性**：  

- 问题：组织的战略目标、利益分配、政策规划、业务流程等高层问题
- 目标：问题的反面，用户的期望
- **特性：选定的、针对目标的解决方案所需要具备的功能特征，通常内聚于一个目标与任务，反映系统与外界一次有价值的完整互动过程**  
  分析手段由浅到深依次为问题分析、目标分析、业务过程分析：  
- 问题与目标明确->问题分析->用例图/上下文图
- 目标之间存在较为复杂的关系->目标分析->目标模型与目标实现
- 目标、特性之间存在紧密的联系->业务过程分析->UML活动图  

### 5.2 问题分析

#### 5.2.1 获取问题

- 收集背景资料：收集业务描述、统计数据，关注业务困难与问题
- 与涉众沟通（面谈）  

#### 5.2.2 明确问题

- 达成共识的问题是一致的问题，但一致的问题不一定是明确的问题。问题的明确性要求它们具备以下两点：易于理解和能指明解决的方向  

- 分析不明确的问题，发现问题背后的问题：直接咨询涉众、利用收集的资料和业务数据、必要的问题分析技巧。  

- > 鱼骨图：显示某个总体效果的可能因子   

#### 5.2.3 发现业务需求

- 每一个明确、一致的问题都意味着涉众存在一些相应的期望目标，即业务需求。
- 一般情况下，业务需求就是问题的反面。  

#### 5.2.4 定义问题解决方案及系统特性

- 建立问题解决方案  
  发现各种可行的高层次解决方案，分析不同方案的业务优势和代价，然后通过和涉众的协商进行选定。提供候选方案，最终由用户决定。  
- 确定系统特性和解决方案的边界  
  - 明确方案具备的功能特征（即**系统特性**）
  - 面向对象方法：用例图（角色：用户；用例：目标-任务）
  - 结构化方法：问题的上下文图（关注信息流输入输出）  
- 确定对解决方案的约束  

### 5.3 目标分析

问题分析将每一个问题都独立对待，这使得它易于操作但却只能适用于简单情况，因为复杂情况下的不同问题之间会存在相互依赖关系  

#### 5.3.1 “目标”概念——面向目标的软件需求工程方法

目标将会补充传统方法中的实体概念和行为概念，成为需求工程建模与分析的基本对象类别。  

#### 5.3.2 目标模型

**目标是系统被开发的目的**  
目标模型的描述需要精确描述和定义，常见基本特征：类型、名称、说明、优先级、可行性……  

- 目标的描述：类型、属性、链接
- 目标的层次：目标可以在不同的抽象层次上进行描述，可以针对不同的内容。高层次目标/低层次目标
- 目标的主体：抽象、粗粒度、范围广的目标拥有更多的主体，区分目标的主体与拥有者：拥有者通常是涉众，这些涉众期望目标达成但不一定参与目标达成过程  
- 目标的分类：功能目标/非功能目标，软目标/硬目标  

元素之间的关系——链接

- 精化：有助于目标完成-AND精化，直接保证目标完成-完备AND精化，替代方案-OR精化  
- 目标阻碍：子目标的达成会使得高层目标失败  
- 目标之间的支持和冲突
- 目标和其他需求模型元素建立链接:  
  Assignment-目标和主体，Operationalization-目标和操作，Covers-目标和场景，Concerns-目标与应用领域对象  

#### 5.3.3 目标分析过程

- 高层目标的获取
- 目标精化  
  - 获取对高层目标的描述
  - 从高层目标描述获取AND精化关系
  - 从高层目标描述中获取“候选方法”，发现OR精化关系
  - 考虑阻碍目标实现的情况
  - 发现目标冲突关系
  - 完善层次结构
- 目标实现

### 5.4 非功能需求分析

#### 5.4.1 为什么需要非功能需求分析

面向产品/面向过程  

#### 5.4.2 非功能需求分析的困难

- 非功能需求不集中，在系统中散布
- 非功能需求不独立，依赖于功能需求
- 非功能需求的质量需求比较复杂
- 非功能需求相互冲突、依赖

#### 5.4.3 使用面向目标的方法分析非功能需求

### 5.5 业务过程分析

#### 5.5.1 活动图

- 节点：动作节点、控制节点、对象节点
- 流：控制流、对象流
- 令牌平衡：验证活动图流转是否正确
- 信号与事件机制：发送动作信号、接收事件动作
- 异常与中断机制：异常处理、可中断活动区
- 分区：活动组、活动分区、泳道
- 层次结构与图简化元素  

#### 5.5.2 使用活动图进行业务过程分析

- 确定活动图的上下文环境 
- 界定业务流程的处理界限 
- 分析业务流程中的主要处理步骤 
- 分析业务流程中的主要数据流 
- 识别参与者，进行职责分配，划分不同的泳道，将处理步骤和数据流的传递组织起来，建立活动图 
- 添加活动图的详细信息，完善活动图描述  

### 5.6 定义系统边界

- 问题分析与系统边界定义  
  每个问题的解决方案边界的合并
- 目标分析与系统边界定义
  - 边界目标：存在系统与环境的互动。
  - 边界目标所覆盖的场景和操纵的操作
  - 关注的数据对象：建立系统边界定义。
- 业务过程分析与系统边界定义  
  依据其动作和对象流完善边界定义  

### 5.7 前景和范围文档



## 6 涉众分析与硬数据采样

### 6.1 什么是涉众

影响软件系统的实现或者被实现后的软件系统所影响的**关键**个人和团体  
用户、客户、开发者、管理者、领域专家等都属于常见涉众  



### 6.2 涉众分析

#### 6.2.1 如何进行涉众分析

按照复杂程度将信息系统分类：  

- 小型系统：涉众有限且明显
- 组织级系统：分析组织内各类人群的互动关系
- 战略信息系统：分析组织内各类人群的互动关系，各种风险/机遇对既有互动关系的影响
- 组织间系统：分析组织间互动关系，分析关系到组织间互动的各类人群在组织内的互动关系  
- 大众型产品：分析产品定位人群，分析用户与社会关系的互动（场景）

#### 6.2.2 涉众分析过程

- 涉众识别
- 涉众描述
- 涉众评估
- 涉众代表选择
- 制定涉众代表参与需求开发乃至软件系统的参与策略  



### 6.3 涉众识别

#### 6.3.1 发现所有的关键涉众类别

- 发现所有涉众类别：  
  最简单的区分特征是任务，不同类别的涉众会执行不同的任务。复杂情况下可以分析涉众之间的互动，发现深层次的信息。  
- 过滤非关键涉众类别：  
  分析一个涉众类别的任务或他们与外界的交互活动，如果属于项目范围，服务于系统目标的满足，就属于关键类型。
- 维护涉众类别：  
  完成分类后继续保持适当的关注  

如果互动及其关注点属于项目的目标与范围，那么涉众就属于**关键涉众**  

#### 6.3.2 识别涉众的方法

- （简单）先膨胀后收缩方法：先尽可能多的列出，再合并
- （经验）检查列表方法
- （经典）涉众网络方法：先找容易发现的初始涉众，然后由初始涉众讨论列出涉众类别列表，缩减、再讨论…… 



### 6.4 涉众描述

#### 6.4.1 描述哪些内容

涉众因素：  

- 涉众的输赢条件
- 涉众的力量与意愿
- 涉众的个人特征与公众特征  

涉众个人特征和工作特征的描述可以帮助更好的确定功能需求；
涉众的输赢条件和受影响程度可以帮助解决涉众之间的需求冲突；
涉众的重要性、影响力、关注点和兴趣取向可以用来发现项目的潜在风险；



### 6.5 涉众评估

#### 6.5.1 优先级评估

优先考虑涉众的基本特征，尤其是任务特征。  
User/Task矩阵。  
Power/Interest分布图：参与者、环境设定者、被影响者、观众。  

#### 6.5.2 风险评估

Power/Attitude分布图：弱支持者、强支持者、弱反对者、强反对者。  
**化解风险**：  

- 提高环境参与者对系统的关注，将他们转变为参与者
- 消除强反对者的反对原因，将他们变为强支持者
- 给予被影响者充分发表和实现自身意见的权力
- 化解弱反对者的忧虑。  

#### 6.5.3 共赢分析（不要忘了这一点，感觉会考到）

**Stakeholder/Issue关系图**  

分析冲突方成为项目赢家的条件，如果没有太大的不一致，通过对期望进行适当调整就可以化解冲突。如果各冲突方成为项目赢家的条件也不可调和，那么需求工程师应该仔细分析项目在该issue上的目标、约束、可选方案，并提供给冲突方进行权衡，促进他们之间协商解决，以尽可能形成一个共赢的局面。

### 6.6 涉众代表选择

#### 6.6.1 涉众采样

完整采样、态度积极、数量适中、比例恰当

#### 6.6.2 用户替代源

和涉众接触频繁的人



### 6.7 涉众参与策略制定

#### 6.7.1 制定涉众参与的基本策略

建立涉众参与矩阵

#### 6.7.2 敏捷方法——用户参与（以用户为中心）

- 建立和用户的直接联系
- 用户参与软件系统开发的整个过程
- 反馈设计：最终的软件系统和用户的活动行为密切相关  



### 6.8 todo

 

### 6.9 硬数据及硬数据采样

#### 6.9.1 硬数据

定量硬数据：数据收集表格、统计报表  
定性硬数据：整个组织的描述化文档、业务指导文档、业务备忘  

#### 6.9.2 硬数据采样

样本大小SS = 0.25*（确定性因子/可接受的错误）^2  



## 7 基于用例/场景模型展开用户需求获取

### 7.1 用户需求获取活动的展开

#### 7.1.1 展开用户需求获取活动时的注意事项

- 用户需求的获取要时刻检查项目边界
- 在面向对象方法中，以用例为线索逐一展开获取过程；在结构化方法中，以系统与外界的输入/输出流为线索逐一展开获取过程

要及时将每次获取的内容组织起来。传统上使用的笔录的方法只是各种资料的简单堆积，是比较散乱的；人们更愿意使用用例/场景模型组织获取到的内容。

#### 7.1.2 用户需求获取活动的主线索——用例/场景模型

- 三个典型的需求层次（p172）
- 用例/场景模型用于组织用户需求的相关内容，用例/场景分析是建立用例/场景模型的过程，但用例/场景分析无法完成对用户需求相关内容正确性、完备性、一致性的验证
- 用例/场景模型能够及时地将每次需求火毒活动的进展组织起来，展现、提供给分析活动，并且得到分析结果后进一步指导后续获取活动。



### 7.2 用例/场景

#### 7.2.1 什么是用例/场景 

- 用例只是一种特殊的场景，是需求工程师在组织需求时更喜欢使用的场景类型
- 用例是在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务
- 每一个行为序列被称为一个场景，一个用例是多个场景的集合
- 每个用例是对相关场景集合（同一目标下的多个场景）的叙述性文本描述，这些场景是用户和系统之间的交互行为序列，互有重合、互为补充。共同实现用户目的

#### 7.2.2 用例/场景的组织特点

用例/场景和用户需求列表是两种不同的对用户需求及相关内容的组织方式

- 用例/场景不仅可以将需求组织成易于理解的故事，而且其内聚性还有助于需求工程师执行获取、分析与验证任务
- 但是其不利于设计师、程序员、测试工程师等开发者的后续工作
- 只要不是受到成本或进度限制，人们还是希望既建立需求的用例/场景组织方式以利于需求阶段的开发工作，又建立需求的列表组织方式以利于后续开发工作
- 用例/场景只是一个故事，但故事的合理性未知
- 用例/场景的弱点：
  - 无法描述其他内容相互之间的联系，如质量需求的相互依赖、界面需求的跳转、对外接口需求与质量需求的联系等
  - 无法分析联系的合理性，如有无遗漏功能需求、数据需求及业务规则是否充分等。

#### 7.2.3 用例/场景的层次性

- 用例/场景可以用于组织业务需求/用户需求/系统级需求的内容
- 一般在需求工程的早期阶段建立最为概要的用例/场景描述，在需求工程的中期阶段（需求获取中）建立用户任务层次的用例/场景描述，在需求工程的后期阶段（需求分析后）建立系统交互层次的用例/场景描述

（具体的表格用例示范见书p178）



### 7.3 用例/场景模型

#### 7.3.1 场景的定位

场景在形式、内容、目的和生命周期4个方面都有差异：  

- 形式：描述场景所使用的表示法的正规性，分别可能为非形式化语言、半形式化语言、形式化语言。在用户需求获取中，建议使用表格、结构化文本和模板等半形式化语言。外观主要有静态、动态和交互三种类型，**在用户需求获取中，建议以静态的场景外观为主**
- 内容：  
  - 主要关注点：关于现在的 ，关于未来的 ，关于解决方案的。**在用户需求获取中，建议关注期待的系统的解决方案**
  - 上下文环境：系统内部，系统外部，系统和环境的交互。**在用户需求获取中，建议使用描述系统与外部环境交互的场景模式** 
  - 抽象层次：具体的、抽象的、混合的。**在用户需求获取中，建议使用抽象场景形式**
  - 覆盖范围：功能需求，非功能需求。**在用户需求获取中，场景覆盖应该以覆盖功能需求为主，依赖于功能需求覆盖其必需的非功能需求** 
  - 粒度 ：**3种形式都会在用户需求获取中得到体现，分别用于其早期中期和后期阶段** 
  - 示例类型：正常流程 ，异常流程。**在用户需求获取中，正常流程和异常流程两种场景形式都需要得到应用，而且最好将它们联合起来应用** 
- 目的：描述、探索和解释。**在用户需求获取中，主要使用场景的探索目的。在获取基本结束时，再使用场景的描述目的（用例文档）**。
- 生命周期（书p184）  感觉可以不看

#### 7.3.2 用例的定位

- 用例是静态的结构化文本描述。
- 用例的内容可以是对当前世界的描述，也可以是对将来确定的解系统的内部行为描述，还可以是对一种期待的解决方案的描述。
- 用例可能会被用于描述系统内部的交互，也可能被用于描述系统和环境的交互，还可能会被用于描述行为的环境和背景。
- 用例是类型层次的事件描述，主要用来描述功能需求。
- 可以包含其他类型的需求
- 用例的内容既包含有正常流程，又包含有异常流程。
- 用例可以是比较抽象的，用于描述整个业务过程；也可以是比较具体的，用于描述某个任务的完成过程；还可以是非常具体的，描述某个交互行为的详细处理步骤。在需求工程的前期，会产生第一种和第二种用例描述，但最终都需要细化为最后一种形式的用例描述。
- 用例可以用于各种目的的应用，包括描述、探索和解释（explanatory）。需求获取和需求验证是它在需求工程中的主要应用阶段，它也可以用于需求的建模、交流和协商。
- 场景的各种生命周期特征、应用和处理过程都适用于用例。

为了达到目标，参与者会执行一些行为。参与者执行的行为会触发自己与其他参与者之间的交互，在交互中其他参与者履行自己的某些职责，满足发起行为的参与者的目标。

#### 7.3.3 用例图

- 用例图的基本元素有4种：用例、参与者、关系、系统边界
- 包含关系、扩展关系、泛化关系（**看书p188示例时，注意区别扩展和泛化**）

感觉泛化就是子继承父并且增加了新的特征，而扩展则是在一开始没想到的流程上进行扩展



### 7.4 以用例/场景模型为主线索展开用户需求获取

（过一遍书即可）  

考前一定要再看一遍，防止在如何开展用户需求获取的主观题里考到



### 7.5 用例文档

略（模板见书p195）  



## 8 需求获取方法之面谈  

### 8.1 概述

面对面的会见被认为是最具丰富内容分交流方法  



### 8.2 准备面谈

- 阅读背景资料
- 确定面谈主题和目标
- 选择被会见者
- 通知被会见者
- 确定问题和类型

#### 8.2.1 准备工作

准备的基础来自于项目的前景与范围定义。前景指出了面谈的方向，范围限定了面谈的主题；涉众分析结果可以帮助更好地选择被会见者和做好准备  

#### 8.2.2 问题类型  

问题基本上可以分为两种类型：  

- 开放式问题：被会见者对答复的选择可以是开放和不受限制的。如“对公司中企业对企业电子商务的当前状态有何看法？”
- 封闭式问题：答案有基本的形式，被会见者的回答是受到限制的。如 “项目存储库每个星期更新多少次？”；“电话中心一个月平均收到多少个电话？”

**程序性提示**：是针对一些人的思维特点而设计的面谈问题，包括：总结和反馈、重复和改述、建立场景和细节描述、抗辩等。  
探究式问题  
诱导性问题（不好）  
双筒问题：指仅使用一个问题的形式，实际上却有两个独立的问题内容。（不好）可以转为探究式问题  
元问题：那些关于面谈本身的问题  （我的问题看起来相关吗、你的回答正式吗、我问了太多问题吗、我还应该见什么人等）

#### 8.2.3 问题准备

前期：

- 开放式问题为主
- 决策层与专家为主
- 遵循问题->目标->解决方案路线
- 分析基本的涉众特点

后期：

- 封闭式问题为主
- 抓住主题与线索：如任务分解、流程图、界面示意
- 问题针对性：任务分解关系、流程正确性、界面中的行为和数据项
- 事先准备面谈记录材料

当遇到让设计面谈问题的题目时，可以按问题->目标->解决方案->涉及的任务及流程；角色->目标、任务->任务特征（频率、优先级等）这两条线来设计

### 8.3 主持面谈

保持面谈主题：对每个主题都在面谈的合适时间安排程序性提示，如在被会见者需要衔接较久的一个主题展开叙述时，使用复述和改述。在被会见者表达一个主题结束时，使用总结和反馈  
使用道具支持：一些简易的模型和草图是可以在面谈中广泛使用的道具  
事实是问题域的特性，问题是需求的来源，所以事实和问题是需求获取的主要获取对象  
面谈记录方式：笔录，录音和摄像  



### 8.4 整理面谈报告

总结面谈信息的主要工作室评估面谈中所得到的信息  
完成面谈报告（具体格式参考课本p208）  



### 8.5 面谈的类别

- 结构化面谈：完全按照事先的问题和结构来控制面谈
- 半结构化面谈：事先需要根据面谈内容准备面谈的问题和面谈结构，但在面谈过程当中，会见者可以根据实际情况采取一些灵活的策略
- 非结构化面谈：没有事先预定的议程安排，甚至会在没有太多事前准备的情况下就直接到访被会见者的工作地，就某个主题开展会谈 

结构化面谈较多使用封闭式问题，所以具有封闭式问题所带来的优缺点；非结构式面谈较多使用开放式问题，所以具有开放式问题所带来的优缺点  
在实际的需求获取中，可以综合考虑结构化面谈和非结构化面谈的折中比较  



### 8.6 面谈的优点和局限性

优点：

- 面谈的开展条件较为简单，经济成本较低；
- 能获得包括事实、问题、被会见者观点、被会见者态度和被会见者信仰等各种信息类型在内的广泛内容；
- 通过面谈，需求工程师可以和涉众（尤其是用户）建立相互之间的友好关系；
- 通过参与面谈，被会见者会产生一种主动为项目做出贡献的感觉，提高涉众的项目参与热情。

缺点：

- 面谈比较耗时，时间成本较高；
- 在被会见者地理分散的情况下往往难以实现面谈；
- 面谈参与者的记忆和交流能力对结果影响较大，尤其是面谈的成功较高的依赖于需求工程师的人际交流能力；
- 交谈当中常见的概念结构不同、模糊化表述、默认知识、潜在知识和态度偏见等各种问题在面谈中都不可避免，进而影响面谈的效果，导致产生不充分的、不相关的或者错误的数据；
- 在会见者不了解被会见者认知结构的情况下，面谈不可能取得令人满意的效果。



### 8.7 其他需求获取方法

- 群体面谈
- 调查问卷
- 头脑风暴：又译为自由讨论，是一种特殊的群体面谈方法。它的目的不是发现需求，而是“发明”需求，或者说是发现“潜在”需求



## 9 需求获取方法之原型

### 9.1 原型及原型法概述

#### 9.1.1 不确定性

- 不确定性是指因为对未来之时了解有限而无法确定某些行为或事件的后果
- 风险是指因为不确定性而可能给未来造成的损失
- 面对不确定的知识，涉众自己是无法解释清楚的，自然也不可能通过面谈告知需求工程师，这就要求需求工程师想办法解决不确定性，主要的手段就是原型

#### 9.1.2 原型及原型法

- 如果在最终的制品产生之前，一个中间制品被用来在一定广度和深度范围内表现这个最终制品，那么这个中间制品就被认为是最终制品在该广度和深度上的原型。
- 原型通常仅仅是真实系统的一个部分或一个模型，重要的不在于使用什么材料和工具来创建它们，而是人们怎么利用它们来探索和论证未来物件的某个方面。
- 包括书面描绘、场景叙述、情节串连图板、幻灯演示、动画模拟、屏幕快照和程序代码等在内的各种被用来探索和论证软件系统功能的物件都是软件的原型

#### 9.1.3 原型的用途

- 演示原型：启动项目阶段，目的是让用户相信应用系统的开发是可行的
- 严格意义上的原型：分析需求阶段，用来阐明用户界面或者系统功能的某些特定方面
- 试验原型：构建系统阶段，帮助开发者澄清它们所面对的一些和系统构建相关的技术问题
- 引示系统原型：会被开发在系统开发的各个阶段，用作最终系统的构建核心

![1542868206910](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1542868206910.png)



### 9.2 使用原型法进行需求获取

#### 9.2.1 基本过程

- 确定原型需求
- 原型开发
- 原型评估
- 原型修正

#### 9.2.2 确定原型需求

- 因为原型方法的成本较高，所以应该只在必要的时候才使用原型方法
- 如果用户需求出现了模糊、不清晰、不完整等具有一定不确定性的特征，就可以考虑使用原型方法

#### 9.2.3 原型开发

注意事项：  

- 将探索不确定功能需求的原型构建的易于修改
- 让探索可行性的原型收集充分的数据
- 控制成本

#### 9.2.4 原型评估

略

#### 9.2.5 原型修正

原型修正一方面要依据评估人员的反馈，另一方面也要考虑事先的原型调整计划，尤其是在开发探索式原型和实验式原型时，事先就应该有设计选项和设计方案的调整计划

**原型一定要开发的容易修改** 



### 9.3 抛弃需求原型

#### 9.3.1 抛弃式原型与演化式原型

- 原型开发方法分类
  - 探索式：以缺陷需求开始，继而不断调整和修正需求的原型开发方式。探索式的原型方法通常要尽可能地调整各种设计选项，并比较多种设计方案下的用户反馈，以得到理想的用户需求
  - 实验式：和探索式原型方法相比，实验式的原型方法初始时就拥有清晰的用户需求，但是开发者对这些需求的实现方法、实现效果和可行性没有太大的把握。
  - 演化式：在演化式的原型方法中，原型的开发并不是一个独立的活动，而是整个项目的持续开发过程中的一部分。
- 前两种原型产品又被称为“抛弃式原型”
- 演化式的原型方法要求原型产品作为资产沿着开发过程向后传递，并可能被后续过程修改和增强，最后成为软件系统的一个部分。因此，演化式原型必须具有健壮性，代码质量要从一开始就能达到最终系统的要求。

#### 9.3.2 坚决抛弃抛弃式原型

代码质量低

抛弃式原型的贡献不在于它的代码，而是它所包含的内容，它说明了正确的需求和正确的技术方案



### 9.4 控制原型成本

#### 9.4.1 依据抛弃式特征控制原型成本

- 花费最小的代价，不要向抛弃式原型添加更多的功能 

#### 9.4.2 控制水平原型的成本

- 用尽可能低的成本开发水平原型

#### 9.4.3 尽量使用简单的介质降低原型成本

![1542868587299](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1542868587299.png)

### 补充

1. 善于使用故事板原型
2. 原型通常和用例/场景结合使用
3. 原型的风险：
   - 投入过多的时间和成本
   - 涉众看到了一个正在运行的原型，得出产品几乎已经完成的结论，从而提出快速交付产品的不当要求
   - 用户可能会被原型所表现出来的非功能特性遮蔽了眼睛，从而忽略了他们更应该重视的功能特性 
   - 在澄清需求不确定性的同时也可能会掩盖一些用户的假设，这些假设将会无从发现 



## 10.观察和文档审查

1. 观察应用于用户无法完成主动的信息告知的情况下。

2. ![1542870472711](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1542870472711.png)

3. 

   |          | 时间采样                                                     | 事件采样                                                |
   | -------- | ------------------------------------------------------------ | ------------------------------------------------------- |
   | 优点     | 通过随机的观察减少偏差    对频繁发生事件取代表性事件进行观察 | 允许在行为展开过程中观察   允许对指定的重要事件进行观察 |
   | 缺点     | 用分段的方式来收集数据不能提供全面信息的时间     漏掉不经常发生却很重要的事件 | 消耗大量时间   漏掉频繁发生事件的代表性样本             |
   | 适用情景 | 发现异常流程   验证用户知识和实际工作的一致性                | 获取默认知识   验证用户知识和实际工作的一致性           |





## 11. 需求分析概述

### 11.1 需求分析的根本任务

1. 建立分析模型，达成开发者和用户对需求信息的共同理解
2. 依据共同理解，发挥创造性，创建软件系统的解决方案

#### 11.1.1 建立分析模型

1. 模型是对事物的抽象，帮助人们在创建一个事物之前有更好的理解

2. 为了更好地理解需求获取所得到的复杂信息，就需要集中关注问题的计算特性（数据、功能、规则等），建立相关的软件模型。

3. 建模常用的两种手段：

   - 抽象：要求人们只关注重要信息。另一方面，也要求人们将认知保留在适当的层次，屏蔽更深层次的细节
   - 分解：分而治之

4. 计算世界与计算模型：使用软件的构成单位作为模型的组元，将软件构建单位之间的关系作为模型组元之间的关系，对获取的信息进行建模。

   不适合进行需求分析中的建模，原因是:

   - 需求工程阶段考虑的重点是软件系统需要解决的问题，缺乏和软件实现相关的技术细节。
   - 软件技术模型的形式化特征不适用于需求工程阶段，是用户所无法理解的。

5. 问题世界与业务模型：使用问题域 中的重要概念作为模型的组元，使用概念之间的业务联系作为组元之间的关系，建立需求信息的模型描述。这种模型的元素都来自于问题域，使用了业务描述的方式，可以认为它们是来自问题世界的业务模型。

   问题世界的非形式化特征使得它同样也不适合进行需求建模。（不准确、不确定、模糊化，不足以用于描述一个有效的软件解决方案）

6. 软件分析模型：介于前两者之间，使用了计算模型的组元形式，以对象、类、函数、过程、属性等作为模型的基本元素。在组元的表现上采用了业务模型的表现方式。

   业务模型是半形式化的，更适应需求工程的建模要求。在需求分析仅仅需要描述解决方案，不需要探索实现细节的情况下，分析模型尤为适用。

7. 分析模型的描述：

   - 模型是对重要知识的集中描述，这种描述是通过模型语言实现的
   - 模型语言的三要素：语法、语义和语用。语法指怎样使用模型的元素，并且以什么方式组织、连接或关联这些元素；语义说明了一个特定模型元素所具有的含义；语用给出了一个模型元素描述的更宽广的上下文，以及影响该模型元素意义的约束和假定
   - 过去的经验告诉我们，必须将需要建模的知识按照关注内容的不同投射为不同的观察视角，从多个观察视角分别描述。这就是与抽象、分解两种手段并列，经常在建模时使用的视点手段
   - 视点手段要求人们在建模一个复杂系统时，从不同的观察角度出发，将系统中既交织共存又相对独立的不同内容拆解成不同的部分，然后分别为每一个拆解后的子部分建模。拆解后的子部分被称为视点。
   - 软件分析模型的复杂性使得需要利用多视点方法对其进行模型描述，即软件分析模型是多个视点模型的集成。这些常见的视点模型有过程模型、实体关系模型、对象模型、状态机模型、行为模型和用例模型等。

8. 需求建模：

   - 软件需求分析的关键是为真实世界的问题建立模型，即问题域建模
   - 问题域与解系统是通过共享知识互相影响的，因此需要建立问题域的模型，发现共享知识，以进一步依据它们建立软件系统的解决方案。
   - 因为复杂系统的建模工作需要用多视点方法来完成，所以在进行问题域建模时可能需要多种类型的模型模式，如过程模型、实体关系模型、对象模型（领域模型）、状态机模型、行为模型和用例模型等。
   - 建立后的解决方案也需要以模型的形式描述出来，即进行解决方案建模

#### 11.1.2 创建解决方案

1. E，R--->S是一个创造性的过程。
2. 设计行为既带有复杂的个人活动痕迹，又具有一定的科学性。



### 11.2 需求分析技术

#### 11.2.1 模型、表示法、技术、方法和工具

总结来说，方法包含技术，技术基于特定的模型语言，模型语言使用表示法，表示法和技术可以由工具来支持，工具也可以支持方法。



#### 11.2.2 常用的需求分析技术

略（p260,后续章节会详细介绍，作为考点复习）



#### 11.2.3 需求分析技术的综合运用

1. 对需求分析技术的 综合运用是需求分析人员最大的困难。
2. 复杂应用需要通过多视角的建模处理。没有哪种需求分析技术能够单独完成对复杂问题的建模任务，只有通过多种需求分析技术的有机结合与集成才能充分描述复杂应用。
3. 方法是技术的一种组合，它们有着共同的组织模式与策略，所以需求分析方法所包含的思想可以在需求分析技术的综合运用上给人们一些启示。



### 11.3 需求分析方法

#### 11.3.1 传统分析

根本没有方法论可言



#### 11.3.2 结构化分析

从功能角度考虑问题



#### 11.3.3 信息工程

是对结构化方法的一种改进，主要从信息角度来开发系统，客观世界被描述为数据和数据属性及其相互关系。

局限性在于它是为信息系统开发而定制的，所以应用范围是有限的。



#### 11.34. 面向对象分析

优点包括自然性和可复用性。人们倾向于按照可感知的对象来思考世界。而且和结构化方法相比，它更容易实现分析到设计的转化。



### 11.4 前期需求阶段的建模与分析

需求分析中需要有面向问题的技术和面向解系统的技术

结构化、信息工程、面向对象的需求分析技术都是面向解系统的，只是采用了问题世界的表现方式而已。

只有面向解系统的技术的缺点：

- 没有仔细考察问题域在问题存在时的状态，而是直接描述了一个问题解决后的状态，无法发现用户群体在问题解决前后可能需要的潜在改变
- 问题没有被深刻理解之前，关于系统边界的决定往往是草率的
- 问题世界是会不断变化的，面向解系统的建模方式使系统的后期维护会越来越困难。

使用面向问题技术对问题世界的建模就被称为前期需求阶段的分析；使用面向解系统的技术对软件系统解决方案的描述就被称为后期需求阶段的分析。

前期需求阶段分析的重点是理解问题世界，因此它关注的是整个问题世界，注重系统的环境、开发组织的业务背景、涉众的特征及目标等。**这些内容在第五章中作了介绍**

面向问题的技术有：

- 面向目标的分析（**在目标分析中介绍过了**）
- 面向问题域的分析：总结出问题框架，如需求行为控制系统、信息系统、工具系统等
- 领域分析：同一应用领域的产品被称为产品族，以软件复用为核心建立产品族的方法被称为产品线。
- 企业建模



### 补充

需求分析技术的综述和分类上的两个框架：

Wieringa框架：

将需求技术分为7个类别：外部功能、外部通信、外部行为、概念组元、组元功能、组元通信、组元行为。它们会依序在需求开发的不同阶段得到应用。

Zachman框架：

与Wieringa框架仅仅关注需求分析技术不同，Zachman框架关注的是软件生产中的所有建模技术。

按照Zachman的矩阵框架，分析技术就是用来对第二行（企业模型）的各列进行建模和描述的技术。

需求分析活动：

主要有背景分析；问题分析、目标分析、业务分析，确定系统边界；需求建模；需求细化；确定需求优先级和需求协商。

1. 需求细化：用户需求细化为系统级需求
2. 确定需求优先级：采用累计投票或者是区域划分的方式
3. 需求协商：涉众之间目标冲突采用共赢分析办法解决。但目标相同的涉众对具体的细节仍可能产生冲突。明确冲突的因素、解决空间，确定最佳解决方案



## 12. 过程建模

### 12.1 概述

1. 过程建模就是分析需求获取活动获得的信息，发现系统的功能及其与外部的交互，建立能够实现系统功能的过程分解结构，形成系统的过程模型，并用图形的方式将过程模型描述出来。同时，过程模型也需要定义系统中涉及的数据的结构。
2. 过程建模使用的主要技术有：上下文图、数据流图、微规格说明和数据字典

### 12.2 数据流图DFD

#### 12.2.1 基本元素

1. 外部实体：需要进行建模的外部实体是那些和待构建系统之间存在着数据交互的外部实体，它们是待构建系统的数据源或数据目的地。

   所有的外部实体联合起来构成了软件系统的外部上下文环境，它们与软件系统的交互流就是软件系统与外部环境的接口，这些接口联合起来定义了软件系统的系统边界。

2. 过程：指施加于数据的动作或行为，它们使数据发生变化。

   它可能是由软件系统控制的，也可能是由人工执行的，其重点在数据发生变化而不是其执行者。

   可能会表现为不同的抽象层次。对于抽象层次较高的过程，建模者会使用功能分解的方式。

3. 数据流：指数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。

   数据流图的数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。

   图形描述中，数据流通常会使用能够代表数据流内容的名词来作为名称，以唯一的标识自己。

   数据流可以分割和组合。

   需求工程师在使用DFD进行过程建模时通常会配合使用**数据字典**，利用数据字典来描述数据流图的数据流内容。

4. 数据存储：是软件系统需要在内部收集、保存，以供日后使用的数据集合。如果说数据流描述的是运动的数据，那么数据存储描述的就是静止的数据。

5. DFD的两种表示方法：DeMarco-Yourdon表示法和Gane-Sarson表示法，具体内容见书p296



#### 12.2.2 规则

1. 过程是对数据的处理，必须有输入，也必须有输出，而且输入数据集和输出数据集应该存在差异。
2. 数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。
3. 数据流图中所有的对象都应该有一个可以唯一标识自己的名称。过程使用动词，外部实体、数据流和数据存储使用名词。



#### 12.2.3 分层结构

1. 上下文图：
   - 将整个系统看作是一个过程，这个过程实现系统的所有功能
   - 上下文图中不会出现数据存储实例（数据存储是系统内部的功能实现）
   - 非常适合于描述系统的应用环境，定义系统边界
2. 0层图：
   - 位于上下文图下面一层
   - 是对上下文图中单一过程的细节描述，是对该单一过程的第一次功能分解，需要在一个图中概括系统的所有功能。
   - 通常用来作为整个系统的功能概图，不应该出现太过具体的过程和数据存储。
3. N层图：
   - 在低于0层图的子图上通常不显示外部实体。父过程的输入输出数据流称为子图的接口流，在子图中从空白区域引出。
   - 如果父过程连接到某个数据存储，则子图可以不包括该数据存储，也可以包括
   - 子图中过程的编号需要以父过程的编号为前缀。



#### 12.2.4 层次结构的建立

1. 创建上下文图                                             

2. 发现并建立DFD片段：

   - 直接从用户需求中概括和归纳出0层图是困难的，一个更可取的做法是根据用户的功能需求建立一些DFD片段，然后再从这些片段中概括和归纳出0层图。
   - DFD片段是系统对某个事件的响应过程的数据流图描述。
   - 在需要概括和归纳系统的整体功能时，可以先从用户需求中发现所有需要系统做出响应的事件，然后为每个事件建立DFD片段描述。这些事件的DFD片段联合起来，就构成了对系统整体功能的描述。

3. 根据DFD片段组合产生0层图：在DFD片段连接起来之后反复进行过程的组合和分解，以产生一个高质量的0层图。

4. 功能分解，产生N层图：在功能分解中，最重要的是要保证分解过程的平衡性，它要求数据流子图的输入流和输出流必须和父过程的保持一致。

   功能分解的过程需要持续执行，直至最终分解产生的子图都是原始数据流图。



### 12.3 逻辑说明——微规格说明

1. 结构化自然语言：结构化英语/伪码

   结构化英语不是伪代码，它不包括声明、初始化和链接之类的技术问题

2. 行为图：是结构化英语的一种特殊表达方式，它使用特定的图示来表示过程的逻辑结构（p307）

3. 决策表：可以比结构化英语更好地描述复杂决策逻辑

4. //todo：补图

5. 决策树：通常是一棵平放的树，树根在左边，树枝从左向右展开。树枝上是有关条件和行动的描述。



### 12.4 数据说明——数据字典

1. 数据字典是一个储存库，包含软件使用和产生的所有数据对象的描述，其中也包括数据流图中数据流和数据存储的定义。
2. 数据字典会有组织地列出数据流图中涉及的所有数据元素（数据流和数据存储），并定义每个数据元素的名称、表示方法、单位/格式、范围、使用地点、使用方法以及其他描述信息。
3. 示例：todo



### 12.5 数据流图的验证

验证数据流图的语法、结构和语义



### 12.6 数据流图创建实例

略



### 12.7 模块结构图

#### 12.7.1 功能分解图

1. 又被称为功能层次图，它在一个图内自上而下集中显示系统的功能分解结构，如下图

   todo

2. 功能分解图最顶层的单独功能通常是对整个系统的使命描述，是对系统业务需求的概括。系统使命说明的下一层称为功能的最顶层，描述了系统应该具备的一些重要功能，它们支撑着系统使命的实现。功能最顶层下面的分支是对最顶层功能执行分解后形成的层次关系。功能分解图最底层是基本的业务功能。

3. 功能分解图描述的仅是功能的概括，并不包含功能执行的先后顺序，也就是说功能分解图描述的并不是系统的过程。



#### 12.7.2 过程依赖图

1. 过程依赖图描述的依赖关系不仅限于数据依赖关系，还包括资源依赖关系和约束依赖关系。

## 13. 数据建模

### 13.1 概述

1. 过程模型更多的是侧重数据产生与使用的时间、地点和方式，而没有描述数据的定义、结构和关系等特性。
2. 数据建模技术就是能够弥补过程建模在数据说明方面的缺陷，描述数据的定义、结构和关系等特性的技术。数据建模建立的模型称为数据模型，是问题域和解系统共享的知识集合。
3. 3种常见的数据模型：
   - 概念数据模型：以问题域的语言解释数据模型。如学生（学号、姓名）
   - 物理数据模型：对数据模型的解系统语言的解释。如student{（number，not null，primary key），（name，varchar50，not null）}
   - 逻辑数据模型：使用中立语言。如学生=（学号，标识符）+（姓名，4位汉字）
4. 在需求工程当中，数据建模建立的是概念数据模型和逻辑数据模型，不涉及物理数据模型。
5. 数据建模最常用的方法是实体关系图。

### 13.2 实体关系图

使用实体、属性和关系3个基本的构建单位来描述数据模型

#### 13.2.1 实体

1. 实体就是实体关系图用来描述事物的元素，是需要在系统中收集和存储的现实世界事物的类别描述。
2. 对归类后的实例集进行的类别描述称为实体
3. 概念实体与逻辑实体：
   - 概念实体是一种抽象概念，不考虑概念背后的物理存在，所以通常不包含与之相关联的其他特征（即属性）。概念实体最常用于项目的计划阶段，帮助人们就大的概念进行交流。
   - 逻辑实体是对概念实体的细化，拥有完整的特征描述。在实体关系图建模中，实体一词所指的通常就是逻辑实体。
4. 进程实体：在实践中，除了静态的事物和抽象的概念外，行为和事件也是常见的实体类型。如一次销售、一次递送。



#### 13.2.2 属性

1. 属性就是可以对实体进行描述的特征。
2. 属性是实体的特征，不是数据。属性会以一定的形式存在，这种存在才是数据，被称为属性的值。
3. 属性的值就应该是一个合法的或者有业务含义的值，这个合法的取值范围称为域（domain）
4. 标识符/键：可以用来唯一的确定和标识每个实例的属性或属性组合
5. 主键、候选键、替代键等概念略，和数据库相同
6. 属性的类型：
   - 单值属性和多值属性
   - 简单属性和组合属性
   - 存储属性和导出属性：从现实当中获取的/由其他属性值计算得出的

#### 13.2.3 关系

1. 关系就是存在于一个或多个实体之间的自然业务联系。
2. 所有关系隐含的都是双向的。
3. 关系的**度数**指参与关系的实体数量。
4. 关系的**基数**又被称为关系的约束。一个实体在关系中的基数定义了在关系中其他实体实例确定的情况下，该实体实例可能参与的关系数量。
5. 基数又被分为最大基数和最小基数。最大基数又称为键约束，最小基数又称为参与约束。many/one  |   mandatory/optional
6. 子类型关系：是一种特殊的实体间关系，它用于处理多个实体大部分相似、少部分不同的情况。（继承）
7. 被关系影响的实体：
   - **弱实体**是指存在和标识需要依赖于其他实体的实体。比方说课程的考试，员工家属的保险
   - 在实体之间建立关系时，可能会产生一些附带的实体。这些附带的实体就称为**关联实体**。也就是说，关联实体是实体之间建立关系时的副产品，它最常见的形式是进程实体。关联实体需要同时依赖于关系中的所有参与实体才能唯一的标识自己。比如学生选择课程时的选择行为。



### 13.3 实体关系图（ERD）的创建

#### 13.3.1 依据充分描述信息的实体关系图创建

1. 辨识实体
2. 确定实体的标识符
3. 建立实体间关系：注意弱实体和关联实体
4. 添加详细的描述信息：包括属性和关系基数等



#### 13.3.2 依据硬数据表单的实体关系图创建

面对复杂的硬数据表单时，可以依照下列步骤建立实体关系图：

1. 分析表单内容，确立表单主题：

   分析表单的内容，确立表单试图说明的几个主题，然后将每个主题描述为一个独立的数据实体。

2. 建立主题之间的关系：

   每张表单都有一个中心主题，它是表单最终要说明的内容。很多其他的主题常常会依赖于中心主题，进而成为弱实体。

3. 围绕主题组织表单的项目：

   在主题确定，并且主题之间关系也建立之后，就可以一一处理表单中包含的项目，将它们分派到各自的主题，并将这些项目作为属性围绕主题组织起来

4. 补充实体关系图的详细信息：

   补充一些详细的信息，包括关系的基数和实体的标识符等。



#### 13.3.3 复杂情况下的实体关系图创建

1. 发现系统的概念域：

   概念域指那些在系统业务中非常重要的概念，它频繁出现在用户的日常对话中。

   概念域只是为数据建模提供一个入手点，因此概念域的发现要全面，不能遗漏那些对业务有重大影响的概念，同时概念域的发现也不要太细节化

2. 建立对概念域的描述

3. 展开概念域：

   以可利用资源为线索，获取并描述概念域所代表的问题域子域。然后结合程序功能对概念域数据的需要，建立概念域局部的数据模型。

4. 合并概念域的局部数据模型



### 13.4 实体关系图与过程模型的联系

1. 结构化的分析方法使用实体关系图来描述系统的数据，使用过程模型来描述系统行为，但是在实体关系图和过程模型之间的协同问题上却始终没有形成有效的解决方案。

2. 目前实现实体关系图和过程模型同步的技术当中，**功能/实体矩阵**是一种较为常见的技术。

   //todo,补图

   表的行反应的是系统的过程模型，列出了系统的功能。

   表的列反映的是系统的数据模型，列出了系统的实体。

   表中的数据单元说明了对应行的功能会对对应列的数据进行怎样的操作。

   操作分为创建create，读取retrieve，更新update，删除delete四种，在单元中分别被标记为C,R,U,D，所以功能/实体矩阵又被称为CRUD矩阵。

## 15 需求规格说明

### 15.1 引言



### 15.2 需求规格说明文档

#### 15.2.1 编写需求规格说明文档的原因

1. 更好的传递软件系统的需求信息和解决方案给开发者（当然，即使是最详细的需求规格说明文档也不能取代项目中的其他交流渠道，保留其他渠道的畅通仍然是重要的）
2. 拓展人们的知识记忆能力
3. ……



#### 15.2.2 需求规格说明文档的类型

- 软件需求规格说明文档
- 硬件需求规格说明文档
- 接口需求规格说明文档
- 人机交互文档



#### 15.2.3 需求规格说明文档的读者

- 项目管理者：根据其进行软件的估算和进度的安排
- 设计人员和程序员
- 测试人员：根据其设计测试计划
- 文档编写人员
- 维护人员：维护和修正都要建立在充分理解软件现有需求的基础上进行
- 培训人员
- 律师



#### 15.2.4 需求规格说明文档的描述手段

todo



### 15.3 模板的选择和使用

软件需求规格说明文档模板见书p400



### 15.4 需求规格说明文档的写作]
