### 2.2 变量

1. 编译器不允许在表达式中仗用这个变量,除非用一个值初始化了该变量。

2. 要声明不同类型的变量,需要使用单独的语句。在同行多个变量的声明中,不能指定不同的数据类型。

3. 大多数现代编译器把没有初始化标记为警告,但C#编译器把它当作错误来看待。这就可以防止我们无意中从其他程序遗留下来的内存中获取垃圾值。

4. 在C#中卖例化一个引用对象需要使用new关键字。如上所述,创建一个引用,使用new关键字把该引用指向存储在堆上的一个对象。

5. **类型推断** ：使用var关键字。声编译器可以根据变量的初始化值“推断”变量的类型。

   var i = 0；

   相当于int i = 0；

   类型推断需要遵循一些规则:

   - 变量必须初始化。否则,编译器就没有推断变量类型的依据。
   - 初始化器不能为空。
   - 初始化器必须放在表达式中。
   - 不能把初始化器设置为一个对象,除非在初始化器中创建了一个新对象。

   声明了变量,推断出了类型后,就不能改变变量类型了。

6. 如果类中和方法中存在同名变量：

   如果要访问一个实例字段(该字段属于类的一个特定实例),就需要使用this关键字。

   如果要访问静态方法中的一个静态字段,不能使用类的实例,只能使用类本身的名称。

7. 常量的值必须能在编译时用于计算。因此,不能用从一个变量中提取的值来初始化常量。如果需要这么做,应使用只读字段。

### 2.3 预定义数据类型

1. C#把数据类型分为两种:

   - 值类型
   - 引用类型

   从概念上看,其区别是值类型直接存储其值,而引用类型存储对值的引用。
   这两种类型存储在内存的不同地方:值类型存储在堆栈中,而引用类型存储在托管堆上。注意区分某个类型是值类型还是引用类型,因为这种存储位置的不同会有不同的影响。

2. 自己声明的类是引用类型。如果要把自己的类型定义为值类型,就应把它声明为一个结构。

3. C#的基本预定义类型并没有内置于C语言中,而是内置于.NET Framework中。例如,在C#中声明一个int类型的数据时,声明的实际上是.NET结构System.Int32的一个实例。

4. C#支持两种预定义的引用类型

   ![1544335947946](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1544335947946.png)

   string a = str1 + str2;

   尽管这是一个值类型的赋值,但string是一个引用类型。String对象被分配在堆上,而不是栈上。因此,当把一个字符串变量赋予另一个字符串时,会得到对内存中同一个字符串的两个引用。但是,string与引用类型在常见的操作上有一些区别。**例如,字符串是不可改变的。修改其中一个字符串,就会创建一个全新的string对象,而另一个字符串不发生任何变化。** （指如果s1和s2原本是指向同一字符串的string对象，当s1修改后，s2依旧指向旧的字符串，不会改变）

5. 可以在字符串字面量的前面加上字符@;在这个字符后的所有字符都看作是其原来的含义——它们不会解释为转义字符。（用来代替反斜杠的一种方式）

### 2.4 流控制

1. C#的switch...case语句更安全，它强制要求所有case后面加上break语句。

   如果激活了块中靠前的一条case子句,后面的case子句就不会被激活,除非使用goto语句特别标记也要激活后面的case子句。编译器会把没有break语句的case子句标记为错误。

   但有一种例外情况。如果一条case子句为空,就可以从这个case跳到下一条case上,这样就可以用相同的方式处理两条或多条case子句了(不需要goto语句)。

2. 四种循环（for， while， do while， foreach）

   foreach循环可以迭代集合中的每一项，**但是不能改变集合中各项的值**

   ```
   foreach (int temp in arrayofInts)
   {
   temp++;
   Console.WriteLine(temp);
   }
   ```

   上面的代码是不能通过编译的

   如果需要迭代集合中的各项，并改变它们的值，就要用for循环。

### 2.5 枚举

![1544338132962](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1544338132962.png)

Enum.Parse(typeof(enum type), string, bool)

（意思似乎是只有一个字符串，靠它去查找在某个特定的枚举类型中是否有对应的枚举值🤔）

### 2.6 名称空间

1. 与文件或组件不同,名称空间是一种逻辑组合,而不是物理组合。

2. 也可以在名称空间中嵌套其他名称空间,为类型创建层次结构。

3. C#允许简写类的全名。为此,要在文件的顶部列出类的名称空间,前面加上using关键字。在文件的其他地方,就可以使用其类型名称来引用名称空间中的类型了:

   几乎所有源代码都以using System；开头

   有点类似于Java的import

4. 可以给名称空间起一个别名来解决名称冲突的问题：

   using alias = Namespace;

   名称空间别名的修饰符是“::”

   ```
   Introduction::NamespaceExample NsEx =
   new Introduction::NamespaceExamp1e();
   ```

### 2.7 Main()方法

### 2.8 有关编译C#文件的更多内容

暂时先跳过，感觉.net课上会讲

### 2.9 控制台I/O

1. WriteLine()方法既可以使用Java般的参数格式，也可以使用C的printf()般的方式。

   可以为值指定宽度、使用格式字符串等。

### 2.10 使用注释

1. C#能够根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释,但都以3条斜杠（///)开头,而不是通常的两条斜杠。在这些注释中,可以把包含类型和类型成员的文档说明的XML标记放在代码中。

   ![1544341456137](C:\Users\50688\AppData\Roaming\Typora\typora-user-images\1544341456137.png)

   C#编译器可以把XML元素从特定的注释中提取出来,并使用它们生成一个XML文件。要让编译器为程序集生成XML文档,需在编译时指定/doc选项,后跟要创建的文件名:

   ```
   csc /t:library /doc:MathLibrary.xml MathLibrary.cs
   ```

### 2.11 C#预处理指令

### 2.12 C#编程规则

1. 在许多情况下,名称都应使用PascaI大小写形式。 Pascal大小写形式指名称中单词的首字母大写,如Employeesalary。注意,名称空间和类,以及基 类中的成员等的名称都应遵循该规则,最好不要使用带有下划线字符的单词。其他语言中常量的名称常常全部大写,但在C#中最好不要这样,因为这种名称很难阅读,而应全部使用Pascal大小写形式的命名约定。

2. 使用Camel大小写形式（第一个单词首字母不大写）的情况：

   - 类型中所有私有成员字段的名称都应是camel大小写形式
   - 传递给方法的所有参数的名称都应是camel大小写形式
   - camel大小写形式也可以用于区分同名的两个对象——比较常见的情况是属性封装一个字段

   ```
   private string emplρyeeName;
   public string Emp1oyeeName
   {
   get
   {
   return employeeName;
   }
   }
   ```



### 3.1 类和结构

1. 结构与类的区别是它们在内存中的存储方式、访问方式(类是存储在堆上的引用类型,而结构是存储在栈上的值类型)和它们的一些特征(如结构不支持继承）。

### 3.2 类

1. 数据和函数都称为类的成员

2. 数据成员是包含类的数据——字段、常量和事件的成员。数据成员可以是静态数据。类成员总是实例成员,除非用static进行显式的声明。

3. 事件是类的成员,在发生某些行为例如改变类的字段或属性,或者进行了某种形式的用户交互操作时,它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第8章将详细介绍事件。

4. 函数成员提供了操作类中数据的某些功能,包括方法、属性、构造函数和终结器（finalizer）、运算符以及索引器。

   终结器似乎类似于析构函数？🤔

5. **属性**是可以从客户端访问的函数组,其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法,所以不必使用那些名称中嵌有Get或set的方法。因为属性的这种语法不同于一般函数的语法,在客户端代码中,虚拟的对象被当做实际的东西。

6. 参数可以通过引用或通过值传递给方法。在变量通过引用传递给方法时,被调用的方法得到的就是这个变量,所以在方法内部对变量进行的任何改变在方法退出后仍旧有效。而如果变量通过值传送给方法,被调用的方法得到的是变量的一个相同副本,也就是说,在方法退出后,对变量进行的修改会丢失。对于复杂的数据类型,按引用传递的效率更高,因为在按值传递时,必须复制大量的数据。

   **当方法参数中有数组时，这就是个引用传递**

7. 如果把一个参数传递给方法,且这个方法的输入参数前带有ref关键字,则该方法对变量所做的任何改变都会影响原始对象的值。

   **在调用该方法时，还需要使用ref关键字**

8. 编译器使用out关键字来初始化。在方法的输入参数前面加上out前缀时,传递给该方法的变量可以不初始化。该变量通过引用传递,所以在从被调用的方法中返回时,对应方法对该变量进行的任何改变都会保留下来。在调用该方法时,还需要使用out关键字,与在定义该方法时一样。

   **用作输出参数** 

   ```
   static void someFunction(out int i)
   {
   i= 100;
   }
   public stat±ic int Main()
   {
   int i; // note how i ig dec△ ared but not initia△ ized.
   someFunCtion(out i);
   Console.WriteLine(i);
   return O;
   }
   ```

9. 参数也可以是可选的。必须为可选参数提供默认值。可选参数还必须是方法定义的最后一个参数。

10. 方法重载的限制：

    - 两个方法不能仅在返回类型上有区别。
    - 两个方法不能仅根据参数是声明为ref还是out来区分。

11. 属性：

    ```
    private int age;
    public int Age
    {
    	get
    	{
            return age;
    	}
    	set
    	{
            age = value;
    	}
    }
    
    ```

    个人理解，属性就是C#用来隐式代替私有字段的set和get方法的一种方式

    只读和只写属性：在属性定义中省略set或get访问器即可。

    可以给属性的访问器设置不同的访问修饰符来设置访问级别，但必须要保证是只读/只写的，而不能是不可读不可写。



```
如果属性的set和get访问器中没有任何逻辑,就可以使用自动实现的属性。这种属性会自动实现后备成员变量。前面Age示例的代码如下:

​```
public int Age{get;set;}
​```
```



```
不需要声明private int age; 编译器会自动创建它。
使用自动实现的属性,就不能在属性设置中验证属性的有效性。所以在上面的例子中,不能检查是否设置了无效的年龄。但必须有两个访问器。尝试把该属性设置为只读属性,就会出错。
```

1. C#的一个新特征是也可以给类编写无参数的静态构造函数。这种构造函数只执行一次。

   编写静态构造函数的一个原因是,类有一些静态字段或属性,需要在第一次使用类之前,从外部源中初始化这些静态字段和属性。

   注意,静态构造函数没有访问修饰符,其他C#代码从来不调用它,但在加载类时,总是由.NET运行库调用它,所以像public或private这样的访问修饰符就没有任何意义。出于同样原因,静态构造函数不能带任何参数,一个类也只能有一个静态构造函数。很显然,静态构造函数只能访问类的静态成员,不能访问类的实例成员。

2. **构造函数初始化器**：

   ```
   c1ass Car
   {
   private string description;
   private uint nWheels;
   public Car(string description, uint nWheels)
   {
     this.description = description;
     this.nWheels = nWhee1s;
   }
   public Car(string description): this(description, 4){
       
   }
   //etc
   ```

   这里this关键字仅调用参数最匹配的那个构造函数。注意,**构造函数初始化器在构造函数的函数体之前执行**。

   C#构造函数初始化器可以包含对同一个类的另一个构造函数的调用(使用前面介绍的语法),也可以包含对直接基类的构造函数的调用(使用相同的语法,但应使用base关键字代替this）。初始化器中不能有多个调用。

3. 有时可能需要一些变量,其值不应改变,但在运行之前其值是未知的。C#为这种情形提供了另一种类型的变量:只读字段。
   readonly关键字比const灵活得多,允许把一个字段设置为常量,但还需要执行一些计算,以确定它的初始值。其规则是可以在构造函数中给只读字段赋值,但不能在其他地方赋值。只读字段还可以是一个实例字段,而不是静态字段,类的每个实例可以有不同的值。与const字段不同,如果要把只读字段设置为静态,就必须显式声明它。

### 3.3 匿名类型

1. var关键字和new关键字一起使用

   ```
   var captain = new (FirstName = "James", MiddleName = "T", LastName = "Kirk");
   var captain = new (person.FirstName, person.MiddleName, person.LastName);
   ```

   这些新对象的类型名未知。编译器为类型伪造了一个名称,但只有编译器才能使用它.

### 3.4 结构

1. 结构是值类型,不是引用类型。它们存储在栈中或存储为内联(inline)（如果它们是存储在堆中的另一个对象的一部分),其生存期的限制与简单的数据类型一样。

   - 结构不支持继承。
   - 对于结构构造函数的工作方式有些区别。尤其是编译器总是提供一个无参数的默认构造函数,它是不允许替换的。
   - 使用结构,可以指定字段如何在内存中的布局(第14章在介绍属性时将详细论述这个问题）

2. ```
   Dimensions point;
   point.Length = 3;
   point.Width = 6;
   ```

   **如果Dimensions是一个类,就会产生一个编译错误,因为point含一个未初始化的引用——不指向任何地方的一个地址,所以不能给其字段设置值。但对于结构,变量声明实际上是为整个结构在栈中分配空间,所以就可以为它赋值了。**

3. 当把结构作为参数传递给方法时,应把它作为ref参数传递,以避免性能损失——此时只传递了结构在内存中的地址,这样传递速度就与在类中的传递速度一样快了。**但如果这样做,就必须注意被调用的方法可以改变结构的值。**

4. 不允许为结构自定义无参数的构造函数（其实是因为.NET运行库不能调用用户提供的自定义无参数构造函数）

### 3.5  部分类

1. partial关键字允许把类、结构或接口放在多个文件中。一般情况下,一个类全部驻留在单个文件中。但有时,多个开发人员需要访问同一个类,或者某种类型的代码生成器生成了一个类的某部分,所以把类放在多个文件中是有益的。
   partial关键字的用法是:把partial放在class、struct或interface关键字的前面。

   如果声明类时使用了public、abstract等关键字，这些关键字就必须应用于同一个类的所有部分。

### 3.6 静态类 

1. 如果一个类只包含静态的方法和属性，该类就是静态的。

   静态类在功能上与使用私有静态构造函数创建的类相同。

   不能创建静态类的实例。

### 3.7 Object类

1. 如果不在自己定义的类中重写ToString()方法,该类将只继承system.Object的实现方式——它显示类的名称。

### 3.8 扩展方法

1. 在没有一个类的源代码的情况下，扩展它的功能的方法。它允许改变一个类,但不需要该类的源代码。
   扩展方法是静态方法,它是类的一部分,但实际上没有放在类的源代码中。

   ```
   namespace Wrox
   {
   public static class MoneyExtension
   {
   public static void AddToAmount(this Money money, decimal amountToAdd)
   {
   money.Amount += amountToAdd;
   }
   }
   }
   ```

   注意AddToAmount方法的参数。对于扩展方法,第一个参数是要扩展的类型,它放在this关键字的后面。这告诉编译器，这个方法是Money类型的一部分。在这个例子中,Money是要扩展的类型。在扩展方法中,可以访问所扩展类型的所有公有方法和属性。

   在主程序调用中，则不需要显示第一个参数。

   即使扩展方法是静态的,也要使用标准的实例方法语法。

### 4.1 继承的类型

1. C#支持实现继承和接口继承。

   - 实现继承是一般意义上的继承
   - 接口继承表示一个类型只继承了函数的签名,没有继承任何实现代码。在需要指定该类型具有某些可用的特性时,最好使用这种类型的继承。

   （其实就是Java里的继承和接口）

2. C#不支持多重继承，但是允许类型派生自多个接口

   和Java一样

3. 结构struct不支持实现继承，但支持接口继承。

   - 结构总是派生自system.ValueType,它们还可以派生自任意多个接口。
   - 类总是派生自用户选择的另一个类,它们还可以派生自任意多个接口。

### 4.2 实现继承

1. 
