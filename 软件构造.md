## 18.09.17
#### 一个好的接口要有：
* 好的抽象：抽象层次要一致
* 好的封装
### 构造函数
#### 1. 尽可能在所有构造函数中初始化所有数据成员：  
对应了不对类的使用者做任何假设  
#### 2. 优先采用深层副本：  
使用深层拷贝，开辟新的空间，以便降低复杂度  
#### 3. 注意只有一个实例化对象的类：  
使用单件模式，私有构造函数  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```


## 类设计
#### 抽象数据类型ADT
指一些数据以及对这些数据所进行的操作的集合。
类 = ADT + 多态 + 继承
#### 良好的类接口
创建高质量的类的第一步，就是创建一个好的接口  
* 好的抽象  
类的接口如果不能展现出一种一致的抽象，那它的内聚性就很弱，可以考虑把子程序组织到几个职能更专一的类里去。  
每个类应该实现一个ADT并且仅实现这个ADT  
提供成对的服务：检查类的每一个公用子程序看看是否需要提供一个与其互补的操作  
把不相关的信息转移到其他类中  
尽可能让接口可编程，而不是表达语义：不对类的使用者做任何假设  
* 好的封装  
尽可能限制类和成员的可访问性  
不要公开暴露成员数据：提供get、set方法，隐藏底层实现  
！避免把私有的实现细节放到类的接口中：如private段在类的头文件中，暴露了实现细节（见书p140）  
不要对类的使用者做出任何假设  
避免使用友元类：有些场合按正确的方式使用友元类有助于管理复杂度，一般情况下友元类会破坏封装  
！要格外警惕从语义上破坏封装性：不能让调用方代码不是依赖于类的公开接口，而是依赖于类的私用实现（书p142）  
#### 有关设计和实现的问题
包含：
* 是一种has a的关系  
* 警惕有超过约7个数据成员的类：7加减2  
继承  
* 是一种is a的关系  
* 要遵循Liskov替换原则：派生类必须能通过基类的接口而被使用，且使用者无需了解两者之间的差异  
* 确保只继承需呀继承的部分：如果只是想使用一个类的实现而不是接口，那么就应该采用包含而不是继承  
* 派生类的成员函数不要与基类中不可覆盖的成员函数重名  
* 把共用的接口、数据及操作放到继承树尽可能高的位置  
成员函数和数据成员：  
* 禁止隐式地产生你不需要的成员函数和运算符：可以通过把构造函数、赋值运算符或者其他成员函数或运算符定义为private，从而禁止调用方代码访问它们  
* 低扇入：减少类所调用的不同子程序的数量  
* 对其他类的子程序的间接调用要尽可能少：遵循迪米特法则：A对象可以任意调研它自己的所有子程序，如果A对象创建了一个B对象，它也可以调用b对象的任何公有子程序，但它应该避免再调用由B对象所提供的对象中的子程序。
构造函数：　
* 尽可能在所有构造函数中初始化所有数据成员：  对应了不对类的使用者做任何假设    
* 用私有构造函数来强制实行单件属性：可以把所有的构造函数都隐藏起来，然后对外提供一个static的getInstance()子程序来访问该类的唯一实例  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```
*  优先采用深层副本：使用深层拷贝，开辟新的空间，以便降低复杂度。对象的深层副本是对象成员数据逐项复制的结果；而其浅层副本则往往只是指向或引用向同一个实际对象。
#### 创建类的原因  
总结：　
* 为现实世界中的对象建模  
* 为抽象对象建模  
* 降低复杂度、隔离复杂度  
* 隐藏实现细节  
* 限制变动的影响范围  
* 隐藏全局数据  ：所谓“全局数据”可能只是对象的数据  
* 让参数传递更顺畅：一个参数在多个子程序之间传递？为什么不做到一个类里  
* 让代码更易于重用  
……  


## 子程序设计  
#### 创建子程序的正当理由  
* 降低复杂度  
* 引入中间、易懂的抽象：把一段代码放入一个命名恰当的子程序中，是说明这段代码用意的最好方法之一  
* 隐藏顺序：把处理事件的顺序隐藏起来  
* 隐藏指针操作  
……  
#### 在子程序层上设计  
要让子程序尽可能的内聚  
**可取的内聚性：**  
* 功能的内聚：最强也是最好的一种内聚性，也就是让一个子程序仅执行一项操作，如sin、cos等  
* 顺序上的内聚：指子程序内包含需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完后才完成了一项完整的功能。如根据出生日期来算年龄，根据年龄算退休时间  
* 通信上的内聚：指一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系  
* 临时的内聚：是指含有一些因为需要同时执行才放到一起的操作的子程序，典型的例子有startup（）、shutdown（）等。为避免这个问题，应该让这个子程序去调用其他子程序，由那些子程序来完成特定的操作，而不是直接由该子程序执行所有的操作  
**不可取的内聚性：**  
* 过程上的内聚：是指一个子程序中的操作是按特定的顺序进行的。如依次获取员工的姓名、住址和电话号码（仅仅是和用户按屏幕提示输入的数据顺序一致）  
* 逻辑上的内聚：是指若干操作被放入同一个子程序中，通过传入控制标志选择执行其中一项操作  
* 巧合的内聚：是指子程序中的各个操作没有任何可以看到的关联  

