## 18.09.17
#### 一个好的接口要有：
* 好的抽象：抽象层次要一致
* 好的封装
### 构造函数
#### 1. 尽可能在所有构造函数中初始化所有数据成员：  
对应了不对类的使用者做任何假设  
#### 2. 优先采用深层副本：  
使用深层拷贝，开辟新的空间，以便降低复杂度  
#### 3. 注意只有一个实例化对象的类：  
使用单件模式，私有构造函数  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```


## 类设计
#### 抽象数据类型ADT
指一些数据以及对这些数据所进行的操作的集合。
类 = ADT + 多态 + 继承
#### 良好的类接口
创建高质量的类的第一步，就是创建一个好的接口  
* 好的抽象  
类的接口如果不能展现出一种一致的抽象，那它的内聚性就很弱，可以考虑把子程序组织到几个职能更专一的类里去。  
每个类应该实现一个ADT并且仅实现这个ADT  
提供成对的服务：检查类的每一个公用子程序看看是否需要提供一个与其互补的操作  
把不相关的信息转移到其他类中  
尽可能让接口可编程，而不是表达语义：不对类的使用者做任何假设  
* 好的封装  
尽可能限制类和成员的可访问性  
不要公开暴露成员数据：提供get、set方法，隐藏底层实现  
！避免把私有的实现细节放到类的接口中：如private段在类的头文件中，暴露了实现细节（见书p140）  
不要对类的使用者做出任何假设  
避免使用友元类：有些场合按正确的方式使用友元类有助于管理复杂度，一般情况下友元类会破坏封装  
！要格外警惕从语义上破坏封装性：不能让调用方代码不是依赖于类的公开接口，而是依赖于类的私用实现（书p142）  
#### 有关设计和实现的问题
包含：
* 是一种has a的关系  
* 警惕有超过约7个数据成员的类：7加减2  
继承  
* 是一种is a的关系  
* 要遵循Liskov替换原则：派生类必须能通过基类的接口而被使用，且使用者无需了解两者之间的差异  
* 确保只继承需呀继承的部分：如果只是想使用一个类的实现而不是接口，那么就应该采用包含而不是继承  
* 派生类的成员函数不要与基类中不可覆盖的成员函数重名  
* 把共用的接口、数据及操作放到继承树尽可能高的位置  
成员函数和数据成员：  
* 禁止隐式地产生你不需要的成员函数和运算符：可以通过把构造函数、赋值运算符或者其他成员函数或运算符定义为private，从而禁止调用方代码访问它们  
* 低扇入：减少类所调用的不同子程序的数量  
* 对其他类的子程序的间接调用要尽可能少：遵循迪米特法则：A对象可以任意调研它自己的所有子程序，如果A对象创建了一个B对象，它也可以调用b对象的任何公有子程序，但它应该避免再调用由B对象所提供的对象中的子程序。
构造函数：　
* 尽可能在所有构造函数中初始化所有数据成员：  对应了不对类的使用者做任何假设    
* 用私有构造函数来强制实行单件属性：可以把所有的构造函数都隐藏起来，然后对外提供一个static的getInstance()子程序来访问该类的唯一实例  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```
*  优先采用深层副本：使用深层拷贝，开辟新的空间，以便降低复杂度。对象的深层副本是对象成员数据逐项复制的结果；而其浅层副本则往往只是指向或引用向同一个实际对象。
#### 创建类的原因  
总结：　
* 为现实世界中的对象建模  
* 为抽象对象建模  
* 降低复杂度、隔离复杂度  
* 隐藏实现细节  
* 限制变动的影响范围  
* 隐藏全局数据  ：所谓“全局数据”可能只是对象的数据  
* 让参数传递更顺畅：一个参数在多个子程序之间传递？为什么不做到一个类里  
* 让代码更易于重用  
……  
p196

