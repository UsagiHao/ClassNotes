## 18.09.17
#### 一个好的接口要有：
* 好的抽象：抽象层次要一致
* 好的封装
### 构造函数
#### 1. 尽可能在所有构造函数中初始化所有数据成员：  
对应了不对类的使用者做任何假设  
#### 2. 优先采用深层副本：  
使用深层拷贝，开辟新的空间，以便降低复杂度  
#### 3. 注意只有一个实例化对象的类：  
使用单件模式，私有构造函数  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```


## 类设计
#### 抽象数据类型ADT
指一些数据以及对这些数据所进行的操作的集合。
类 = ADT + 多态 + 继承
#### 良好的类接口
创建高质量的类的第一步，就是创建一个好的接口  
* 好的抽象  
类的接口如果不能展现出一种一致的抽象，那它的内聚性就很弱，可以考虑把子程序组织到几个职能更专一的类里去。  
每个类应该实现一个ADT并且仅实现这个ADT  
提供成对的服务：检查类的每一个公用子程序看看是否需要提供一个与其互补的操作  
把不相关的信息转移到其他类中  
尽可能让接口可编程，而不是表达语义：不对类的使用者做任何假设  
* 好的封装  
尽可能限制类和成员的可访问性  
不要公开暴露成员数据：提供get、set方法，隐藏底层实现  
！避免把私有的实现细节放到类的接口中：如private段在类的头文件中，暴露了实现细节（见书p140）  
不要对类的使用者做出任何假设  
避免使用友元类：有些场合按正确的方式使用友元类有助于管理复杂度，一般情况下友元类会破坏封装  
！要格外警惕从语义上破坏封装性：不能让调用方代码不是依赖于类的公开接口，而是依赖于类的私用实现（书p142）  
#### 有关设计和实现的问题
包含：
* 是一种has a的关系  
* 警惕有超过约7个数据成员的类：7加减2  
继承  
* 是一种is a的关系  
* 要遵循Liskov替换原则：派生类必须能通过基类的接口而被使用，且使用者无需了解两者之间的差异  
* 确保只继承需呀继承的部分：如果只是想使用一个类的实现而不是接口，那么就应该采用包含而不是继承  
* 派生类的成员函数不要与基类中不可覆盖的成员函数重名  
* 把共用的接口、数据及操作放到继承树尽可能高的位置  
成员函数和数据成员：  
* 禁止隐式地产生你不需要的成员函数和运算符：可以通过把构造函数、赋值运算符或者其他成员函数或运算符定义为private，从而禁止调用方代码访问它们  
* 低扇入：减少类所调用的不同子程序的数量  
* 对其他类的子程序的间接调用要尽可能少：遵循迪米特法则：A对象可以任意调研它自己的所有子程序，如果A对象创建了一个B对象，它也可以调用b对象的任何公有子程序，但它应该避免再调用由B对象所提供的对象中的子程序。
构造函数：　
* 尽可能在所有构造函数中初始化所有数据成员：  对应了不对类的使用者做任何假设    
* 用私有构造函数来强制实行单件属性：可以把所有的构造函数都隐藏起来，然后对外提供一个static的getInstance()子程序来访问该类的唯一实例  
```
public class MaxId {
   // constructors and destructors
   private MaxId() {   ...   }      ...

   // public routines
   public static MaxId GetInstance() {       
      return m_instance;
   }     ...

   // private members
   private static final MaxId m_instance = new MaxId();       ...
}
```
*  优先采用深层副本：使用深层拷贝，开辟新的空间，以便降低复杂度。对象的深层副本是对象成员数据逐项复制的结果；而其浅层副本则往往只是指向或引用向同一个实际对象。
#### 创建类的原因  
总结：　
* 为现实世界中的对象建模  
* 为抽象对象建模  
* 降低复杂度、隔离复杂度  
* 隐藏实现细节  
* 限制变动的影响范围  
* 隐藏全局数据  ：所谓“全局数据”可能只是对象的数据  
* 让参数传递更顺畅：一个参数在多个子程序之间传递？为什么不做到一个类里  
* 让代码更易于重用  
……  


## 子程序设计  
#### 创建子程序的正当理由  
* 降低复杂度  
* 引入中间、易懂的抽象：把一段代码放入一个命名恰当的子程序中，是说明这段代码用意的最好方法之一  
* 隐藏顺序：把处理事件的顺序隐藏起来  
* 隐藏指针操作  
……  
#### 在子程序层上设计  
要让子程序尽可能的内聚  
**可取的内聚性：**  
* 功能的内聚：最强也是最好的一种内聚性，也就是让一个子程序仅执行一项操作，如sin、cos等  
* 顺序上的内聚：指子程序内包含需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完后才完成了一项完整的功能。如根据出生日期来算年龄，根据年龄算退休时间  
* 通信上的内聚：指一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系  
* 临时的内聚：是指含有一些因为需要同时执行才放到一起的操作的子程序，典型的例子有startup（）、shutdown（）等。为避免这个问题，应该让这个子程序去调用其他子程序，由那些子程序来完成特定的操作，而不是直接由该子程序执行所有的操作  

**不可取的内聚性：**  
* 过程上的内聚：是指一个子程序中的操作是按特定的顺序进行的。如依次获取员工的姓名、住址和电话号码（仅仅是和用户按屏幕提示输入的数据顺序一致）  
* 逻辑上的内聚：是指若干操作被放入同一个子程序中，通过传入控制标志选择执行其中一项操作  
* 巧合的内聚：是指子程序中的各个操作没有任何可以看到的关联  
#### 好的子程序的名字  
* 描述子程序所做的事情  
* 避免使用无意义的、模糊或表述不清的动词，如processinput（）、dealwithoutput（）等，最多就是告诉你这些子程序要做的事情和输入输出有关  
* 不要仅通过数字来形成不同的子程序的名字  
* 使用强烈的动词加宾语的形式  
* 准确使用对仗词，如add/remove, show/hide等  
#### 子程序可以写多长  
在面向对象的程序中，一大部分都是访问器子程序，它们都非常短小。在任何时候，复杂的算法总会导致更长的子程序。在这种情况下，可以允许子程序的长度有序的增长至100-200行。与其对子程序的行数加以限制，还不如让子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、注释数量以及其他一些跟复杂度相关的考虑事项等来决定子程序的长度  
#### 如何使用子程序参数  
* 按照输入-修改-输出的顺序排列参数：不要随机的或按字母顺序排列参数，而应该先列出仅作为输入用途的参数，然后是即作为输入又作为输出用途的参数，最后才是仅作为输出用途的参数。  
* 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致：方便产生记忆效应  
* 使用所有的参数：不用到的话就把它从子程序的接口中删去  
* 把状态或出错变量放在最后：它们只是附属于子程序的主要功能，而且它们是仅用于输出的参数  
* 不要把子程序的参数用作工作变量：如在子程序中改变参数inputVal的值，在其他地方使用原有输入值的时候可能就会产生错误（在C++中可以利用const关键字。当一个参数被标记为const时，在子程序中就不能修改其值）  
* 在接口中对参数的假定加以说明  
* 把子程序的参数个数限制在大约7个以内：如果一直需要传递很多参数，这就说明子程序之间的耦合太过紧密了  
* 考虑对参数采用某种表示输入、修改、输出的命名规则  
* **为子程序传递用以维持其接口抽象的变量或对象（p179）**  
#### 宏子程序和内联子程序（C++）  
* **把宏表达式整个包含在括号内，否则可能不能正确的展开（p183）**  
* 把含有多条语句的宏用大括号括起来  
通常认为，用宏来代替函数调用的做法具有风险而且不易理解。因此，除非必要，否则还是应该避免使用这种技术  
* 用给子程序命名的方法来给展开后代码形同子程序的宏命名，以便在需要时可以用子程序来替换宏。  
C++支持inline关键字。inline子程序允许程序员在编写代码时把代码当成子程序，但编译器在编译期间通常会把每一处调用inline子程序的地方都转换为插入内嵌的代码。因为避免了子程序调用的开销，因此inline机制可以产生非常高效的代码。  
**但是inline子程序违反了封装的原则**，因为C++要求把inline子程序的实现代码放在头文件里，从而也就把这些实现细节暴露给了所有使用该头文件的程序员  


## 防御式编程  
#### 保护程序免遭非法输入数据的破坏  
检查所有来源于外部的数据的值、检查子程序所有输入参数的值  
#### 断言  
断言是指开发期间使用的、让程序在运行时进行自检的代码。断言为真，则表明程序运行正常，而断言为假，则意味着发现了意料之外的错误  
一个断言通常含有两个参数：一个描述假设为真时的情况的布尔表达式，和一个断言为假时需要显示的信息  
```
assert denominator != 0 : "denominator is unexpectdedly equal to 0.";
```
声明除数不为0的断言  
通常，断言只是在开发阶段被编译到目标代码中，而在生成产品代码时不编译进去  
**用错误处理代码来处理预期会发生的情况，用断言来处理绝不应该发生的状况**：断言是用来检查永远不该发生的情况，而错误处理代码是用来检查不太可能经常发生的非正常情况  
避免把需要执行的代码放到断言中  
**用断言来注解并验证前条件和后条件**
* 前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为真的属性。前条件是调用方代码对其所调用的代码要承担的义务  
* 后条件是子程序或类在执行结束后要确保为真的属性。后条件是子程序或类对调用方代码所承担的责任  
对于高健壮性的代码，应该先使用断言再处理错误  
#### 错误处理技术  
* 返回中立值：0，空串，空指针等  
* 换用下一个正确的数据  
* 换用最接近的合法值  
……  

处理错误最恰当的方式要根据出现错误的软件的类别而定。错误处理方式有时更侧重于正确性，有时更侧重于健壮性。**正确性**意味着永不返回不准确的结果，哪怕不反悔结果也比返回不准确的结果要好。**健壮性**意味着要不断尝试采取某些措施，以保证软件可以持续地运转下去，哪怕有时做出一些不够准确的结果  
#### 异常  
//todo p202

#### 隔栏

#### 辅助调试的代码
不要自动地把产品版的限制强加于开发版之上：应该在开发期间牺牲一些速度和对资源的使用，来换取一些让开发更顺畅的内置工具    
尽早引入辅助调试的代码  
计划移除调试辅助的代码：  
* //todo
* 使用宏/宏子程序
* 使用调试存根（debugging stubs）

#### 确定在产品中该保留多少防御式代码
* 保留那些检查重要错误的代码：确定程序的哪些部分可以承担未检测出错误而造成的后果，而哪些部分不能承担
* 去掉检查细微错误的代码
* 去掉可以导致程序硬性崩溃的代码
* 保留可以让程序稳妥地崩溃的代码
* 为你的技术支持人员记录错误信息
* 确认留在代码中的错误信息是友好的


## 变量
隐式声明：编译器自动声明使用前未被声明的变量，是危险的。难以发现使用错误的变量  
当语言支持隐式声明时：
* 关闭隐式声明
* 声明全部变量
* 遵循某种命名规则
* //todo

变量初始化原则：
* 在声明变量的时候初始化（防御式编程方法）
* 不允许在声明变量时初始化的语言，在靠近变量第一次使用的地方声明和·初始化
* 理想情况下，在靠近第一次使用变量的时候声明和初始化变量  
* 在可能的情况下使用final和const
* 特别注意计数器和累加器：不要忘记下次使用前重置其值
* 在类的构造函数里初始化该类的数据成员  
* 检查是否需要重新初始化：确保初始化语句位于那些重复执行的代码内部
* 一次性初始化具名常量

变量的作用域：
* 使变量引用局部化

变量跨度：同一变量相邻两次使用之间间隔的代码行数  
存活时间：一个变量存活期间所跨越的语句总数。保持较低的存活时间，减小攻击窗口，提高代码可读性  

减小作用域的一般原则：
* 在循环开始之前再去初始化该循环里使用的变量，而不是在循环所在的子程序开始时
* //todo
* 把相关语句放在一起
