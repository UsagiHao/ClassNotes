## chapter1 MySQL架构与历史

###  1.1 MySQL逻辑架构
//todo:MySQL服务器逻辑架构图 

* 最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
* 第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
* 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势。存储引擎API包含了几十个底层函数，但存储引擎不会去解析SQL（注释：InnoDB是一个例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能），不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。 

#### 1.1.2 优化和执行
* MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。（第6章详细讨论）
* 对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。（第7章详细讨论）



### 1.2 并发控制

#### 1.2.1 读写锁
在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock），也叫读锁（read lock）和排他锁（exclusive lock），也叫写锁（write lock）。读锁可以同时进行，而写锁会阻塞其它的读锁和写锁，这是出于安全策略的考虑，防止用户读取正在写入的同一资源。
#### 1.2.2 锁粒度
* 一种提高共享资源并发性的方式就是让锁定对象更有选择性。最理想的方式是，只对会修改的数据片进行精确的锁定。在不发生冲突的情况下，锁定的数据量越小，则系统并发程度越高。
* 锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。
* 表锁（table lock）：表锁是MySQL中最基本的锁策略，并且是开销最小的策略。
  行级锁（row lock）：行级锁最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。



### 1.3 事务
* 事务是一组原子性的SQL查询，或者说是一个独立的工作单元。
* START TRANSACTION（开始事务）；ROLLBACK（回滚）；COMMIT（提交）。
* 一个运行良好的事务处理系统，必须具备ACID特征。原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。
* 原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
* 一致性（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态。如果事务没有提交，那么事务中所做的修改就不会保存到数据库。
* 隔离性（isolation）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
* 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 1.3.1 隔离级别
* 未提交读（READ UNCOMMITED）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读（Dirty Read）。这个级别会导致很多问题，性能上也不比其他级别好太多
* 提交读（READ COMMITED）：除MySQL外的大多数数据库系统的默认隔离级别。提交读满足了隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。这个级别也叫不可重复读（nonrepeatable read），因为两次执行同样的查询，可能得到不一样的结果。
* 可重复读（REPEATABLE READ）：这是MySQL的默认事务隔离级别，解决了脏读的问题，保证了在同一事务中多次读取同样的记录的结果是一致的。但无法解决幻读（Phantom Read）的问题。幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。
* 可串行化（SERIALIZABLE）：最高隔离级别。它通过强制事务串行执行，避免了幻行的问题。可串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有数据的一致性要求很高，并且可以接受没有并发的情况下，才考虑使用。 

#### 1.3.2 死锁
* 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
* 数据库系统实现了各种死锁检测和死锁超时机制。InnoDB处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（相对比较简单的死锁回滚算法）。
* 数据冲突和存储引擎的实现方式都会导致死锁的产生。对于事务型的系统，死锁是无法避免的，所以应用程序在设计时就必须考虑如何处理死锁，大多数情况下只需要重新执行因死锁回滚的事务即可。

#### 1.3.3 事务日志
事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘中的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回磁盘。目前大多数存储引擎都是这样实现的，通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。


### 1.4 多版本并发控制
* MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，它一般都同时实现了多版本并发控制（MVCC）。
* MVCC可以认为是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。
* MVCC的实现，是通过保存数据在某个时间点的快照来实现的。避免了事务开始的时间不同，而看到不同的数据。
* InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两列，一列保存了行的创建时间，一个保存了行的过期时间（或删除时间），等同系统版本号。通过获取适当的版本号的内容来操作数据，保证数据时间上的一致性。
* MVCC只在REPEATABLE READ和READ COMMIT两个隔离级别下工作。其它两个都和MVCC不兼容，因为READ UNCOMMIT总是读取最新的数据行，而不是符合当前事务版本的数据行；而SERIALIZABLE则会对所有读取的行都加锁。





