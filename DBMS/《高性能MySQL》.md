## chapter1 MySQL架构与历史

### 1.1 MySQL逻辑架构

//todo:MySQL服务器逻辑架构图 

- 最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- 第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势。存储引擎API包含了几十个底层函数，但存储引擎不会去解析SQL（注释：InnoDB是一个例外，它会解析外键定义，因为MySQL服务器本身没有实现该功能），不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。 

#### 1.1.2 优化和执行

- MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。（第6章详细讨论）
- 对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。（第7章详细讨论）



### 1.2 并发控制

#### 1.2.1 读写锁

在处理并发读或写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock），也叫读锁（read lock）和排他锁（exclusive lock），也叫写锁（write lock）。读锁可以同时进行，而写锁会阻塞其它的读锁和写锁，这是出于安全策略的考虑，防止用户读取正在写入的同一资源。

#### 1.2.2 锁粒度

- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。最理想的方式是，只对会修改的数据片进行精确的锁定。在不发生冲突的情况下，锁定的数据量越小，则系统并发程度越高。
- 锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。
- 表锁（table lock）：表锁是MySQL中最基本的锁策略，并且是开销最小的策略。
  行级锁（row lock）：行级锁最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。



### 1.3 事务

- 事务是一组原子性的SQL查询，或者说是一个独立的工作单元。
- START TRANSACTION（开始事务）；ROLLBACK（回滚）；COMMIT（提交）。
- 一个运行良好的事务处理系统，必须具备ACID特征。原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。
- 原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
- 一致性（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态。如果事务没有提交，那么事务中所做的修改就不会保存到数据库。
- 隔离性（isolation）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 1.3.1 隔离级别

- 未提交读（READ UNCOMMITED）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读（Dirty Read）。这个级别会导致很多问题，性能上也不比其他级别好太多
- 提交读（READ COMMITED）：除MySQL外的大多数数据库系统的默认隔离级别。提交读满足了隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。这个级别也叫不可重复读（nonrepeatable read），因为两次执行同样的查询，可能得到不一样的结果。
- 可重复读（REPEATABLE READ）：这是MySQL的默认事务隔离级别，解决了脏读的问题，保证了在同一事务中多次读取同样的记录的结果是一致的。但无法解决幻读（Phantom Read）的问题。幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。
- 可串行化（SERIALIZABLE）：最高隔离级别。它通过强制事务串行执行，避免了幻行的问题。可串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有数据的一致性要求很高，并且可以接受没有并发的情况下，才考虑使用。 

#### 1.3.2 死锁

- 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
- 数据库系统实现了各种死锁检测和死锁超时机制。InnoDB处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（相对比较简单的死锁回滚算法）。
- 数据冲突和存储引擎的实现方式都会导致死锁的产生。对于事务型的系统，死锁是无法避免的，所以应用程序在设计时就必须考虑如何处理死锁，大多数情况下只需要重新执行因死锁回滚的事务即可。

#### 1.3.3 事务日志

事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘中的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回磁盘。目前大多数存储引擎都是这样实现的，通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

### 1.4 多版本并发控制

- MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，它一般都同时实现了多版本并发控制（MVCC）。
- MVCC可以认为是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。
- MVCC的实现，是通过保存数据在某个时间点的快照来实现的。避免了事务开始的时间不同，而看到不同的数据。
- InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两列，一列保存了行的创建时间，一个保存了行的过期时间（或删除时间），等同系统版本号。通过获取适当的版本号的内容来操作数据，保证数据时间上的一致性。
- MVCC只在REPEATABLE READ和READ COMMIT两个隔离级别下工作。其它两个都和MVCC不兼容，因为READ UNCOMMIT总是读取最新的数据行，而不是符合当前事务版本的数据行；而SERIALIZABLE则会对所有读取的行都加锁。



## chapter2 MySQL基准测试

基准测试（benchmark）是MySQL新手和专家都需要掌握的一项基本技能。简单地说，基准测试是针对系统设计的一种压力测试。通常的目标是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者做新硬件的可靠性测试。

### 2.1 为什么需要基准测试

略

### 2.2 基准测试的策略

1. 基准测试有两种主要的策略：一是针对整个系统的整体测试，另外是单独测试MySQL。这两种策略也被称为集成式（full-stack）以及单组件式（single-component）基准测试。

#### 2.2.1 测试何种指标

- 吞吐量 
  吞吐量指的是单位时间内的事务处理数。常用的测试单位是每秒事务数（TPS），有些也采用每分钟事务数（TPM）。

- 响应时间或者延迟 
  这个指标用于测试任务所需的整体时间。根据具体的应用，测试的时间单位可能是微秒、毫秒、秒或分钟。根据不同的时间单位可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比。通常可以使用百分比响应时间（percentile response time）来替代最大响应时间。

- 并发性 
  注意不要将创建数据库连接和并发性搞混淆。一个设计良好的应用，同时可以打开成百上千个MySQL数据库服务器连接，但可能同时只有少数连接在执行查询。所以说，一个Web站点“同时有50000个用户”访问，却可能只有10~15个并发请求到MySQL数据库。 
  换句话说，并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数。当并发性增加时，需要测试吞吐量是否下降，响应时间是否变长，如果是这样，应用可能就无法处理峰值压力。 
  并发性的测量完全不同于响应时间和吞吐量。它不像是一个结果，而更像是设置基准测试的一种属性。并发性测试通常不是为了测试应用能达到的并发度，而是为了测试应用在不同并发下的性能。当然，数据库的并发性还是需要测量的。可以通过sysbench指定32、64或128个线程的测试，然后在测试期间记录MySQL数据库的Threads_running状态值。

- **可扩展性** 
  简单地说，可扩展性指的是，给系统增加一倍的工作，在理想情况下就能获得两倍的结果（即吞吐量增加一倍）。或者说，给系统增加一倍的资源（比如两倍的CPU数），就可以获得两倍的吞吐量。当然，同时性能（响应时间）也必须在可以接受的范围内。大多数系统是无法做到如此理想的线性扩展的。随着压力的变化，吞吐量和性能都可能越来越差。 


### 2.3 基准测试方法

以下常见错误可能导致测试结果无用或者不精确 

1. 使用真实数据的子集而不是全集。 
2. 使用错误的数据分布。 
3. 使用不真实的分布参数。 
4. 在多用户场景中，只做单用户的测试。 
5. 在单服务器上测试分布式应用。 
6. 与真实用户行为不匹配。 
7. 反复执行同一个查询。 
8. 没有检查错误。基准测试完成后，一定要检查一下错误日志，这应该是基本的要求。 
9. 忽略了系统预热（warm up）的过程。 
10. 使用默认的服务器配置。 
11. 测试时间太短。 
    如果其他条件相同，就应努力使测试过程尽可能地接近真实应用的情况。

#### 2.3.1 设计和规划基准测试

1. 规划基准测试的第一步是提出问题并明确目标。然后决定是采用标准的基准测试，还是设计专用的测试。

2. 如果采用标准的基准测试，应该确认选择了合适的测试方案。

3. 设计专用的基准测试是很复杂的，往往需要一个迭代的过程。首先需要获得生产数据集的快照，并且该快照很容易还原，以便进行后续的测试。然后，针对数据运行查询。可以建立一个单元测试集作为初步的测试，并运行多遍。但是这和真实的数据库环境还是有差别的。更好的办法是选择一个有代表性的时间段，记录生产系统上的所有查询。如果时间段选得比较小，则可以选择多个时间段。这样有助于覆盖整个系统的活动状态。

4. 可以在不同级别记录查询。如果是集成式（full-stack）基准测试，可以记录Web服务器上的HTTP请求，也可以打开MySQL的查询日志（Query Log）。倘若要重演这些查询，就要确保创建多线程来并行执行，而不是单个线程线性地执行。对日志中的每个连接都应该创建独立的线程，而不是将所有的查询随机地分配到一些线程中。查询日志中记录了每个查询是在哪个连接中执行的。

5. 即使不需要创建专用的基准测试，详细地写下测试规划也是必需的。测试可能要多次反复运行，因此需要精确地重现测试过程，而且也要考虑到下次测试不是同一个人的情况。

6. 应该建立将参数和结果文档化的规范，每一轮测试都必须进行详细记录。需要记住的是，经常要写一些脚本来分析测试结果，因此如果能够不用打开文档等额外操作，当然是更好的。


#### 2.3.2 基准测试应该运行多长时间

- 基准测试应该运行足够长的时间，这一点很重要。有时候无法确认测试需要多长的时间才足够，如果这样可以让测试一直运行，持续观察直到确认系统已经稳定。一个简单的测试规则，就是等系统看起来稳定的时间至少等于系统预热的时间。


#### 2.3.3 获取系统性能和状态

- 在执行基准测试时，需要尽可能多地收集被测试系统的信息。
- 使用shell脚本，尽可能多的收集数据，多余一些数据总比缺乏重要的数据要好。需要记录的数据包括系统状态和性能指标。



#### 2.3.4 获得准确的测试结果

- 获得准确测试结果的最好办法，是回答一些关于基准测试的基本问题：是否选择了正确的基准测试？是否为问题收集了相关的数据？是否采用了错误的测试标准？
- 接着，确认测试结果是否可重复。每次重新测试之前要确保系统状态的一致，甚至有必要重启系统并预热，还需要确保预热的时间足够长，并可重复。如果预热采用的随机查询，那么测试结果可能就是不可重复的。
- 每次测试要保证测试数据相同，一个确保物理磁盘数据的分布尽可能一直的办法是，每次都进行快速格式化并进行磁盘分区复制。
- 每次测试中，修改的参数应该尽量少，有时参数之间的依赖性会给测试带来复杂性。一般情况下，都是通过迭代逐步地修改基准测试的参数，而避免每次运行都做大量的修改。
- 基于MySQL默认配置的测试没有什么意义。
- 如果测试中出现异常结果，不要轻易当作坏数据点而丢弃。分析这些异常结果，偶尔也会获得意想不到的收获。



#### 2.3.5 运行基准测试并分析结果

- 通常来说，自动化基准测试可以获得更精确的测试结果。要尽可能地使所有测试过程都自动化，包括装载数据、系统预热、执行测试、记录结果等。
- 基准测试通常要运行多次，以提高测试结果的准确度。
- 获得测试结果后，还需要对结果进行分析，最终目的是回答在设计测试时的问题。
- 如何从数据中抽象出有意义的结果，依赖于如何收集数据。通常使用脚本来分析数据，不仅减轻分析的工作量，也易于文档化。



#### 2.3.6 绘图的重要性

在执行基准测试的时候尽可能地收集更多的细节数据，然后将数据绘制成图形，这样可以帮助快速地发现问题。

### 2.4 基准测试工具

#### 2.4.1 集成式测试工具

#### 2.4.2 单组件式测试工具



### 2.5 基准测试案例（P52~P65）



## chapter3 服务器性能剖析

暂时略过



## chapter4 Schema与数据类型优化 

